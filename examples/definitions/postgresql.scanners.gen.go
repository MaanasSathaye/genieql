package definitions

import (
	"database/sql"
	"time"

	"github.com/lib/pq"
)

// DO NOT MODIFY: This File was auto generated by the following command:
// genieql generate experimental scanners types -o postgresql.scanners.gen.go
// invoked by go generate @ definitions/example.go line 5

// ProfileScanner scanner interface.
type ProfileScanner interface {
	Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error
	Next() bool
	Close() error
	Err() error
}

type errProfileScanner struct {
	e error
}

func (t errProfileScanner) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	return t.e
}

func (t errProfileScanner) Next() bool {
	return false
}

func (t errProfileScanner) Err() error {
	return t.e
}

func (t errProfileScanner) Close() error {
	return nil
}

const ProfileScannerStaticColumns = "i1,i2,b1,t1"

// NewProfileScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewProfileScannerStatic(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return profileScannerStatic{
		Rows: rows,
	}
}

type profileScannerStatic struct {
	Rows *sql.Rows
}

func (t profileScannerStatic) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 pq.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return t.Rows.Err()
}

func (t profileScannerStatic) Err() error {
	return t.Rows.Err()
}

func (t profileScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t profileScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewProfileScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewProfileScannerStaticRow(row *sql.Row) ProfileScannerStaticRow {
	return ProfileScannerStaticRow{
		row: row,
	}
}

type ProfileScannerStaticRow struct {
	row *sql.Row
}

func (t ProfileScannerStaticRow) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 pq.NullTime
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return nil
}

// NewProfileScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewProfileScannerDynamic(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return profileScannerDynamic{
		Rows: rows,
	}
}

type profileScannerDynamic struct {
	Rows *sql.Rows
}

func (t profileScannerDynamic) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	const (
		i10 = "i1"
		i21 = "i2"
		b12 = "b1"
		t13 = "t1"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullInt64
		c1      sql.NullInt64
		c2      sql.NullBool
		c3      pq.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case i10:
			dst = append(dst, &c0)
		case i21:
			dst = append(dst, &c1)
		case b12:
			dst = append(dst, &c2)
		case t13:
			dst = append(dst, &c3)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case i10:
			if c0.Valid {
				tmp := int(c0.Int64)
				*i1 = tmp
			}
		case i21:
			if c1.Valid {
				tmp := int(c1.Int64)
				*i2 = tmp
			}
		case b12:
			if c2.Valid {
				tmp := c2.Bool
				*b1 = tmp
			}
		case t13:
			if c3.Valid {
				tmp := c3.Time
				*t1 = tmp
			}
		}
	}

	return t.Rows.Err()
}

func (t profileScannerDynamic) Err() error {
	return t.Rows.Err()
}

func (t profileScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t profileScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// Example1Scanner scanner interface.
type Example1Scanner interface {
	Scan(e *Example1) error
	Next() bool
	Close() error
	Err() error
}

type errExample1Scanner struct {
	e error
}

func (t errExample1Scanner) Scan(e *Example1) error {
	return t.e
}

func (t errExample1Scanner) Next() bool {
	return false
}

func (t errExample1Scanner) Err() error {
	return t.e
}

func (t errExample1Scanner) Close() error {
	return nil
}

const Example1ScannerStaticColumns = "created_at,id,text_field,updated_at,uuid_field"

// NewExample1ScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewExample1ScannerStatic(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return example1ScannerStatic{
		Rows: rows,
	}
}

type example1ScannerStatic struct {
	Rows *sql.Rows
}

func (t example1ScannerStatic) Scan(e *Example1) error {
	var (
		c0 pq.NullTime
		c1 sql.NullInt64
		c2 sql.NullString
		c3 pq.NullTime
		c4 sql.NullString
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		e.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		e.ID = tmp
	}

	if c2.Valid {
		tmp := c2.String
		e.TextField = &tmp
	}

	if c3.Valid {
		tmp := c3.Time
		e.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.String
		e.UUIDField = tmp
	}

	return t.Rows.Err()
}

func (t example1ScannerStatic) Err() error {
	return t.Rows.Err()
}

func (t example1ScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t example1ScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewExample1ScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewExample1ScannerStaticRow(row *sql.Row) Example1ScannerStaticRow {
	return Example1ScannerStaticRow{
		row: row,
	}
}

type Example1ScannerStaticRow struct {
	row *sql.Row
}

func (t Example1ScannerStaticRow) Scan(e *Example1) error {
	var (
		c0 pq.NullTime
		c1 sql.NullInt64
		c2 sql.NullString
		c3 pq.NullTime
		c4 sql.NullString
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		e.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		e.ID = tmp
	}

	if c2.Valid {
		tmp := c2.String
		e.TextField = &tmp
	}

	if c3.Valid {
		tmp := c3.Time
		e.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.String
		e.UUIDField = tmp
	}

	return nil
}

// NewExample1ScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewExample1ScannerDynamic(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return example1ScannerDynamic{
		Rows: rows,
	}
}

type example1ScannerDynamic struct {
	Rows *sql.Rows
}

func (t example1ScannerDynamic) Scan(e *Example1) error {
	const (
		created_at0 = "created_at"
		id1         = "id"
		text_field2 = "text_field"
		updated_at3 = "updated_at"
		uuid_field4 = "uuid_field"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pq.NullTime
		c1      sql.NullInt64
		c2      sql.NullString
		c3      pq.NullTime
		c4      sql.NullString
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case created_at0:
			dst = append(dst, &c0)
		case id1:
			dst = append(dst, &c1)
		case text_field2:
			dst = append(dst, &c2)
		case updated_at3:
			dst = append(dst, &c3)
		case uuid_field4:
			dst = append(dst, &c4)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case created_at0:
			if c0.Valid {
				tmp := c0.Time
				e.CreatedAt = tmp
			}
		case id1:
			if c1.Valid {
				tmp := int(c1.Int64)
				e.ID = tmp
			}
		case text_field2:
			if c2.Valid {
				tmp := c2.String
				e.TextField = &tmp
			}
		case updated_at3:
			if c3.Valid {
				tmp := c3.Time
				e.UpdatedAt = tmp
			}
		case uuid_field4:
			if c4.Valid {
				tmp := c4.String
				e.UUIDField = tmp
			}
		}
	}

	return t.Rows.Err()
}

func (t example1ScannerDynamic) Err() error {
	return t.Rows.Err()
}

func (t example1ScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t example1ScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// ComboScanner scanner interface.
type ComboScanner interface {
	Scan(e1 *Example1, e2 *Example2) error
	Next() bool
	Close() error
	Err() error
}

type errComboScanner struct {
	e error
}

func (t errComboScanner) Scan(e1 *Example1, e2 *Example2) error {
	return t.e
}

func (t errComboScanner) Next() bool {
	return false
}

func (t errComboScanner) Err() error {
	return t.e
}

func (t errComboScanner) Close() error {
	return nil
}

const ComboScannerStaticColumns = "created_at,id,text_field,updated_at,uuid_field,bool_field,created_at,text_field,updated_at,uuid_field"

// NewComboScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewComboScannerStatic(rows *sql.Rows, err error) ComboScanner {
	if err != nil {
		return errComboScanner{e: err}
	}

	return comboScannerStatic{
		Rows: rows,
	}
}

type comboScannerStatic struct {
	Rows *sql.Rows
}

func (t comboScannerStatic) Scan(e1 *Example1, e2 *Example2) error {
	var (
		c0 pq.NullTime
		c1 sql.NullInt64
		c2 sql.NullString
		c3 pq.NullTime
		c4 sql.NullString
		c5 sql.NullBool
		c6 pq.NullTime
		c7 sql.NullString
		c8 pq.NullTime
		c9 sql.NullString
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		e1.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		e1.ID = tmp
	}

	if c2.Valid {
		tmp := c2.String
		e1.TextField = &tmp
	}

	if c3.Valid {
		tmp := c3.Time
		e1.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.String
		e1.UUIDField = tmp
	}

	if c5.Valid {
		tmp := c5.Bool
		e2.BoolField = tmp
	}

	if c6.Valid {
		tmp := c6.Time
		e2.CreatedAt = tmp
	}

	if c7.Valid {
		tmp := c7.String
		e2.TextField = tmp
	}

	if c8.Valid {
		tmp := c8.Time
		e2.UpdatedAt = tmp
	}

	if c9.Valid {
		tmp := c9.String
		e2.UUIDField = tmp
	}

	return t.Rows.Err()
}

func (t comboScannerStatic) Err() error {
	return t.Rows.Err()
}

func (t comboScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t comboScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewComboScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewComboScannerStaticRow(row *sql.Row) ComboScannerStaticRow {
	return ComboScannerStaticRow{
		row: row,
	}
}

type ComboScannerStaticRow struct {
	row *sql.Row
}

func (t ComboScannerStaticRow) Scan(e1 *Example1, e2 *Example2) error {
	var (
		c0 pq.NullTime
		c1 sql.NullInt64
		c2 sql.NullString
		c3 pq.NullTime
		c4 sql.NullString
		c5 sql.NullBool
		c6 pq.NullTime
		c7 sql.NullString
		c8 pq.NullTime
		c9 sql.NullString
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		e1.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		e1.ID = tmp
	}

	if c2.Valid {
		tmp := c2.String
		e1.TextField = &tmp
	}

	if c3.Valid {
		tmp := c3.Time
		e1.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.String
		e1.UUIDField = tmp
	}

	if c5.Valid {
		tmp := c5.Bool
		e2.BoolField = tmp
	}

	if c6.Valid {
		tmp := c6.Time
		e2.CreatedAt = tmp
	}

	if c7.Valid {
		tmp := c7.String
		e2.TextField = tmp
	}

	if c8.Valid {
		tmp := c8.Time
		e2.UpdatedAt = tmp
	}

	if c9.Valid {
		tmp := c9.String
		e2.UUIDField = tmp
	}

	return nil
}

// NewComboScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewComboScannerDynamic(rows *sql.Rows, err error) ComboScanner {
	if err != nil {
		return errComboScanner{e: err}
	}

	return comboScannerDynamic{
		Rows: rows,
	}
}

type comboScannerDynamic struct {
	Rows *sql.Rows
}

func (t comboScannerDynamic) Scan(e1 *Example1, e2 *Example2) error {
	const (
		created_at0 = "created_at"
		id1         = "id"
		text_field2 = "text_field"
		updated_at3 = "updated_at"
		uuid_field4 = "uuid_field"
		bool_field5 = "bool_field"
		created_at6 = "created_at"
		text_field7 = "text_field"
		updated_at8 = "updated_at"
		uuid_field9 = "uuid_field"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pq.NullTime
		c1      sql.NullInt64
		c2      sql.NullString
		c3      pq.NullTime
		c4      sql.NullString
		c5      sql.NullBool
		c6      pq.NullTime
		c7      sql.NullString
		c8      pq.NullTime
		c9      sql.NullString
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case created_at0:
			dst = append(dst, &c0)
		case id1:
			dst = append(dst, &c1)
		case text_field2:
			dst = append(dst, &c2)
		case updated_at3:
			dst = append(dst, &c3)
		case uuid_field4:
			dst = append(dst, &c4)
		case bool_field5:
			dst = append(dst, &c5)
		case created_at6:
			dst = append(dst, &c6)
		case text_field7:
			dst = append(dst, &c7)
		case updated_at8:
			dst = append(dst, &c8)
		case uuid_field9:
			dst = append(dst, &c9)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case created_at0:
			if c0.Valid {
				tmp := c0.Time
				e1.CreatedAt = tmp
			}
		case id1:
			if c1.Valid {
				tmp := int(c1.Int64)
				e1.ID = tmp
			}
		case text_field2:
			if c2.Valid {
				tmp := c2.String
				e1.TextField = &tmp
			}
		case updated_at3:
			if c3.Valid {
				tmp := c3.Time
				e1.UpdatedAt = tmp
			}
		case uuid_field4:
			if c4.Valid {
				tmp := c4.String
				e1.UUIDField = tmp
			}
		case bool_field5:
			if c5.Valid {
				tmp := c5.Bool
				e2.BoolField = tmp
			}
		case created_at6:
			if c6.Valid {
				tmp := c6.Time
				e2.CreatedAt = tmp
			}
		case text_field7:
			if c7.Valid {
				tmp := c7.String
				e2.TextField = tmp
			}
		case updated_at8:
			if c8.Valid {
				tmp := c8.Time
				e2.UpdatedAt = tmp
			}
		case uuid_field9:
			if c9.Valid {
				tmp := c9.String
				e2.UUIDField = tmp
			}
		}
	}

	return t.Rows.Err()
}

func (t comboScannerDynamic) Err() error {
	return t.Rows.Err()
}

func (t comboScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t comboScannerDynamic) Next() bool {
	return t.Rows.Next()
}
