package definitions

import (
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

// DO NOT MODIFY: This File was auto generated by the following command:
// genieql generate experimental scanners types -o postgresql.scanners.gen.go
// invoked by go generate @ definitions/example.go line 5

// ProfileScanner scanner interface.
type ProfileScanner interface {
	Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error
	Next() bool
	Close() error
	Err() error
}

type errProfileScanner struct {
	e error
}

func (t errProfileScanner) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	return t.e
}

func (t errProfileScanner) Next() bool {
	return false
}

func (t errProfileScanner) Err() error {
	return t.e
}

func (t errProfileScanner) Close() error {
	return nil
}

// ProfileScannerStaticColumns generated by genieql
const ProfileScannerStaticColumns = `"i1","i2","b1","t1"`

// NewProfileScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewProfileScannerStatic(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return profileScannerStatic{
		Rows: rows,
	}
}

// profileScannerStatic generated by genieql
type profileScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t profileScannerStatic) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t profileScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t profileScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t profileScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewProfileScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewProfileScannerStaticRow(row *sql.Row) ProfileScannerStaticRow {
	return ProfileScannerStaticRow{
		row: row,
	}
}

// ProfileScannerStaticRow generated by genieql
type ProfileScannerStaticRow struct {
	row *sql.Row
}

// Scan generated by genieql
func (t ProfileScannerStaticRow) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 sql.NullTime
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return nil
}

// NewProfileScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewProfileScannerDynamic(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return profileScannerDynamic{
		Rows: rows,
	}
}

// profileScannerDynamic generated by genieql
type profileScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t profileScannerDynamic) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	const (
		cn0 = "i1"
		cn1 = "i2"
		cn2 = "b1"
		cn3 = "t1"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullInt64
		c1      sql.NullInt64
		c2      sql.NullBool
		c3      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := int(c0.Int64)
				*i1 = tmp
			}
		case cn1:
			if c1.Valid {
				tmp := int(c1.Int64)
				*i2 = tmp
			}
		case cn2:
			if c2.Valid {
				tmp := c2.Bool
				*b1 = tmp
			}
		case cn3:
			if c3.Valid {
				tmp := c3.Time
				*t1 = tmp
			}
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t profileScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t profileScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t profileScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// Example1Scanner scanner interface.
type Example1Scanner interface {
	Scan(e *Example1) error
	Next() bool
	Close() error
	Err() error
}

type errExample1Scanner struct {
	e error
}

func (t errExample1Scanner) Scan(e *Example1) error {
	return t.e
}

func (t errExample1Scanner) Next() bool {
	return false
}

func (t errExample1Scanner) Err() error {
	return t.e
}

func (t errExample1Scanner) Close() error {
	return nil
}

// Example1ScannerStaticColumns generated by genieql
const Example1ScannerStaticColumns = `"bigint_field","bit_field","bit_varying_field","bool_field","byte_array_field","character_field","character_fixed_field","cidr_field","decimal_field","double_precision_field","inet_field","int2_array","int4_array","int8_array","int_field","interval_field","json_field","jsonb_field","macaddr_field","numeric_field","real_field","smallint_field","text_field","timestamp_field","uuid_array","uuid_field"`

// NewExample1ScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewExample1ScannerStatic(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return example1ScannerStatic{
		Rows: rows,
	}
}

// example1ScannerStatic generated by genieql
type example1ScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example1ScannerStatic) Scan(e *Example1) error {
	var (
		c0  pgtype.Int8
		c1  pgtype.Bit
		c2  pgtype.Varbit
		c3  pgtype.Bool
		c4  pgtype.Bytea
		c5  pgtype.Varchar
		c6  pgtype.BPChar
		c7  pgtype.CIDR
		c8  pgtype.Numeric
		c9  pgtype.Float8
		c10 pgtype.Inet
		c11 pgtype.Int2Array
		c12 pgtype.Int4Array
		c13 pgtype.Int8Array
		c14 pgtype.Int4
		c15 pgtype.Interval
		c16 pgtype.JSON
		c17 pgtype.JSONB
		c18 pgtype.Macaddr
		c19 pgtype.Numeric
		c20 pgtype.Float4
		c21 pgtype.Int2
		c22 pgtype.Text
		c23 pgtype.Timestamptz
		c24 pgtype.UUIDArray
		c25 pgtype.UUID
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Int
		e.BigintField = tmp
	}

	if c1.Valid {
		tmp := c1.Bytes
		e.BitField = tmp
	}

	if c2.Valid {
		tmp := c2.Bytes
		e.BitVaryingField = tmp
	}

	if c3.Valid {
		tmp := c3.Bool
		e.BoolField = tmp
	}

	if c4.Valid {
		tmp := c4.Bytes
		e.ByteArrayField = tmp
	}

	if c5.Valid {
		tmp := c5.String
		e.CharacterField = tmp
	}

	if c6.Valid {
		tmp := c6.String
		e.CharacterFixedField = tmp
	}

	if c7.Valid {
		tmp := c7.IPNet
		e.CidrField = tmp
	}

	if c8.Valid {
		tmp := c8.Int
		e.DecimalField = tmp
	}

	if c9.Valid {
		tmp := c9.Float
		e.DoublePrecisionField = tmp
	}

	if c10.Valid {
		tmp := c10.IPNet
		e.InetField = tmp
	}

	if c11.Valid {
		tmp := c11.Elements
		e.Int2Array = tmp
	}

	if c12.Valid {
		tmp := c12.Elements
		e.Int4Array = tmp
	}

	if c13.Valid {
		tmp := c13.Elements
		e.Int8Array = tmp
	}

	if c14.Valid {
		tmp := c14.Int
		e.IntField = tmp
	}

	if c15.Valid {
		tmp := c15.Microseconds
		e.IntervalField = tmp
	}

	if c16.Valid {
		tmp := c16.Bytes
		e.JSONField = tmp
	}

	if c17.Valid {
		tmp := c17.Bytes
		e.JsonbField = tmp
	}

	if c18.Valid {
		tmp := c18.Addr
		e.MacaddrField = tmp
	}

	if c19.Valid {
		tmp := c19.Int
		e.NumericField = tmp
	}

	if c20.Valid {
		tmp := c20.Float
		e.RealField = tmp
	}

	if c21.Valid {
		tmp := c21.Int
		e.SmallintField = tmp
	}

	if c22.Valid {
		tmp := c22.String
		e.TextField = tmp
	}

	if c23.Valid {
		tmp := c23.Time
		e.TimestampField = tmp
	}

	if c24.Valid {
		tmp := c24.Elements
		e.UUIDArray = tmp
	}

	if c25.Valid {
		tmp := c25.Bytes
		e.UUIDField = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example1ScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example1ScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example1ScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewExample1ScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewExample1ScannerStaticRow(row *sql.Row) Example1ScannerStaticRow {
	return Example1ScannerStaticRow{
		row: row,
	}
}

// Example1ScannerStaticRow generated by genieql
type Example1ScannerStaticRow struct {
	row *sql.Row
}

// Scan generated by genieql
func (t Example1ScannerStaticRow) Scan(e *Example1) error {
	var (
		c0  pgtype.Int8
		c1  pgtype.Bit
		c2  pgtype.Varbit
		c3  pgtype.Bool
		c4  pgtype.Bytea
		c5  pgtype.Varchar
		c6  pgtype.BPChar
		c7  pgtype.CIDR
		c8  pgtype.Numeric
		c9  pgtype.Float8
		c10 pgtype.Inet
		c11 pgtype.Int2Array
		c12 pgtype.Int4Array
		c13 pgtype.Int8Array
		c14 pgtype.Int4
		c15 pgtype.Interval
		c16 pgtype.JSON
		c17 pgtype.JSONB
		c18 pgtype.Macaddr
		c19 pgtype.Numeric
		c20 pgtype.Float4
		c21 pgtype.Int2
		c22 pgtype.Text
		c23 pgtype.Timestamptz
		c24 pgtype.UUIDArray
		c25 pgtype.UUID
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Int
		e.BigintField = tmp
	}

	if c1.Valid {
		tmp := c1.Bytes
		e.BitField = tmp
	}

	if c2.Valid {
		tmp := c2.Bytes
		e.BitVaryingField = tmp
	}

	if c3.Valid {
		tmp := c3.Bool
		e.BoolField = tmp
	}

	if c4.Valid {
		tmp := c4.Bytes
		e.ByteArrayField = tmp
	}

	if c5.Valid {
		tmp := c5.String
		e.CharacterField = tmp
	}

	if c6.Valid {
		tmp := c6.String
		e.CharacterFixedField = tmp
	}

	if c7.Valid {
		tmp := c7.IPNet
		e.CidrField = tmp
	}

	if c8.Valid {
		tmp := c8.Int
		e.DecimalField = tmp
	}

	if c9.Valid {
		tmp := c9.Float
		e.DoublePrecisionField = tmp
	}

	if c10.Valid {
		tmp := c10.IPNet
		e.InetField = tmp
	}

	if c11.Valid {
		tmp := c11.Elements
		e.Int2Array = tmp
	}

	if c12.Valid {
		tmp := c12.Elements
		e.Int4Array = tmp
	}

	if c13.Valid {
		tmp := c13.Elements
		e.Int8Array = tmp
	}

	if c14.Valid {
		tmp := c14.Int
		e.IntField = tmp
	}

	if c15.Valid {
		tmp := c15.Microseconds
		e.IntervalField = tmp
	}

	if c16.Valid {
		tmp := c16.Bytes
		e.JSONField = tmp
	}

	if c17.Valid {
		tmp := c17.Bytes
		e.JsonbField = tmp
	}

	if c18.Valid {
		tmp := c18.Addr
		e.MacaddrField = tmp
	}

	if c19.Valid {
		tmp := c19.Int
		e.NumericField = tmp
	}

	if c20.Valid {
		tmp := c20.Float
		e.RealField = tmp
	}

	if c21.Valid {
		tmp := c21.Int
		e.SmallintField = tmp
	}

	if c22.Valid {
		tmp := c22.String
		e.TextField = tmp
	}

	if c23.Valid {
		tmp := c23.Time
		e.TimestampField = tmp
	}

	if c24.Valid {
		tmp := c24.Elements
		e.UUIDArray = tmp
	}

	if c25.Valid {
		tmp := c25.Bytes
		e.UUIDField = tmp
	}

	return nil
}

// NewExample1ScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewExample1ScannerDynamic(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return example1ScannerDynamic{
		Rows: rows,
	}
}

// example1ScannerDynamic generated by genieql
type example1ScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example1ScannerDynamic) Scan(e *Example1) error {
	const (
		cn0  = "bigint_field"
		cn1  = "bit_field"
		cn2  = "bit_varying_field"
		cn3  = "bool_field"
		cn4  = "byte_array_field"
		cn5  = "character_field"
		cn6  = "character_fixed_field"
		cn7  = "cidr_field"
		cn8  = "decimal_field"
		cn9  = "double_precision_field"
		cn10 = "inet_field"
		cn11 = "int2_array"
		cn12 = "int4_array"
		cn13 = "int8_array"
		cn14 = "int_field"
		cn15 = "interval_field"
		cn16 = "json_field"
		cn17 = "jsonb_field"
		cn18 = "macaddr_field"
		cn19 = "numeric_field"
		cn20 = "real_field"
		cn21 = "smallint_field"
		cn22 = "text_field"
		cn23 = "timestamp_field"
		cn24 = "uuid_array"
		cn25 = "uuid_field"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pgtype.Int8
		c1      pgtype.Bit
		c2      pgtype.Varbit
		c3      pgtype.Bool
		c4      pgtype.Bytea
		c5      pgtype.Varchar
		c6      pgtype.BPChar
		c7      pgtype.CIDR
		c8      pgtype.Numeric
		c9      pgtype.Float8
		c10     pgtype.Inet
		c11     pgtype.Int2Array
		c12     pgtype.Int4Array
		c13     pgtype.Int8Array
		c14     pgtype.Int4
		c15     pgtype.Interval
		c16     pgtype.JSON
		c17     pgtype.JSONB
		c18     pgtype.Macaddr
		c19     pgtype.Numeric
		c20     pgtype.Float4
		c21     pgtype.Int2
		c22     pgtype.Text
		c23     pgtype.Timestamptz
		c24     pgtype.UUIDArray
		c25     pgtype.UUID
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		case cn12:
			dst = append(dst, &c12)
		case cn13:
			dst = append(dst, &c13)
		case cn14:
			dst = append(dst, &c14)
		case cn15:
			dst = append(dst, &c15)
		case cn16:
			dst = append(dst, &c16)
		case cn17:
			dst = append(dst, &c17)
		case cn18:
			dst = append(dst, &c18)
		case cn19:
			dst = append(dst, &c19)
		case cn20:
			dst = append(dst, &c20)
		case cn21:
			dst = append(dst, &c21)
		case cn22:
			dst = append(dst, &c22)
		case cn23:
			dst = append(dst, &c23)
		case cn24:
			dst = append(dst, &c24)
		case cn25:
			dst = append(dst, &c25)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Int
				e.BigintField = tmp
			}
		case cn1:
			if c1.Valid {
				tmp := c1.Bytes
				e.BitField = tmp
			}
		case cn2:
			if c2.Valid {
				tmp := c2.Bytes
				e.BitVaryingField = tmp
			}
		case cn3:
			if c3.Valid {
				tmp := c3.Bool
				e.BoolField = tmp
			}
		case cn4:
			if c4.Valid {
				tmp := c4.Bytes
				e.ByteArrayField = tmp
			}
		case cn5:
			if c5.Valid {
				tmp := c5.String
				e.CharacterField = tmp
			}
		case cn6:
			if c6.Valid {
				tmp := c6.String
				e.CharacterFixedField = tmp
			}
		case cn7:
			if c7.Valid {
				tmp := c7.IPNet
				e.CidrField = tmp
			}
		case cn8:
			if c8.Valid {
				tmp := c8.Int
				e.DecimalField = tmp
			}
		case cn9:
			if c9.Valid {
				tmp := c9.Float
				e.DoublePrecisionField = tmp
			}
		case cn10:
			if c10.Valid {
				tmp := c10.IPNet
				e.InetField = tmp
			}
		case cn11:
			if c11.Valid {
				tmp := c11.Elements
				e.Int2Array = tmp
			}
		case cn12:
			if c12.Valid {
				tmp := c12.Elements
				e.Int4Array = tmp
			}
		case cn13:
			if c13.Valid {
				tmp := c13.Elements
				e.Int8Array = tmp
			}
		case cn14:
			if c14.Valid {
				tmp := c14.Int
				e.IntField = tmp
			}
		case cn15:
			if c15.Valid {
				tmp := c15.Microseconds
				e.IntervalField = tmp
			}
		case cn16:
			if c16.Valid {
				tmp := c16.Bytes
				e.JSONField = tmp
			}
		case cn17:
			if c17.Valid {
				tmp := c17.Bytes
				e.JsonbField = tmp
			}
		case cn18:
			if c18.Valid {
				tmp := c18.Addr
				e.MacaddrField = tmp
			}
		case cn19:
			if c19.Valid {
				tmp := c19.Int
				e.NumericField = tmp
			}
		case cn20:
			if c20.Valid {
				tmp := c20.Float
				e.RealField = tmp
			}
		case cn21:
			if c21.Valid {
				tmp := c21.Int
				e.SmallintField = tmp
			}
		case cn22:
			if c22.Valid {
				tmp := c22.String
				e.TextField = tmp
			}
		case cn23:
			if c23.Valid {
				tmp := c23.Time
				e.TimestampField = tmp
			}
		case cn24:
			if c24.Valid {
				tmp := c24.Elements
				e.UUIDArray = tmp
			}
		case cn25:
			if c25.Valid {
				tmp := c25.Bytes
				e.UUIDField = tmp
			}
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example1ScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example1ScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example1ScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// ComboScanner scanner interface.
type ComboScanner interface {
	Scan(e1 *Example1, e2 *Example2) error
	Next() bool
	Close() error
	Err() error
}

type errComboScanner struct {
	e error
}

func (t errComboScanner) Scan(e1 *Example1, e2 *Example2) error {
	return t.e
}

func (t errComboScanner) Next() bool {
	return false
}

func (t errComboScanner) Err() error {
	return t.e
}

func (t errComboScanner) Close() error {
	return nil
}

// NewComboScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewComboScannerStatic(rows *sql.Rows, err error) ComboScanner {
	if err != nil {
		return errComboScanner{e: err}
	}

	return comboScannerStatic{
		Rows: rows,
	}
}

// comboScannerStatic generated by genieql
type comboScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t comboScannerStatic) Scan(e1 *Example1, e2 *Example2) error {
	var (
		c0  pgtype.Int8
		c1  pgtype.Bit
		c2  pgtype.Varbit
		c3  pgtype.Bool
		c4  pgtype.Bytea
		c5  pgtype.Varchar
		c6  pgtype.BPChar
		c7  pgtype.CIDR
		c8  pgtype.Numeric
		c9  pgtype.Float8
		c10 pgtype.Inet
		c11 pgtype.Int2Array
		c12 pgtype.Int4Array
		c13 pgtype.Int8Array
		c14 pgtype.Int4
		c15 pgtype.Interval
		c16 pgtype.JSON
		c17 pgtype.JSONB
		c18 pgtype.Macaddr
		c19 pgtype.Numeric
		c20 pgtype.Float4
		c21 pgtype.Int2
		c22 pgtype.Text
		c23 pgtype.Timestamptz
		c24 pgtype.UUIDArray
		c25 pgtype.UUID
		c26 pgtype.Bool
		c27 pgtype.Int4Array
		c28 pgtype.Int8Array
		c29 pgtype.Text
		c30 pgtype.Timestamptz
		c31 pgtype.UUIDArray
		c32 pgtype.UUID
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25, &c26, &c27, &c28, &c29, &c30, &c31, &c32); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Int
		e1.BigintField = tmp
	}

	if c1.Valid {
		tmp := c1.Bytes
		e1.BitField = tmp
	}

	if c2.Valid {
		tmp := c2.Bytes
		e1.BitVaryingField = tmp
	}

	if c3.Valid {
		tmp := c3.Bool
		e1.BoolField = tmp
	}

	if c4.Valid {
		tmp := c4.Bytes
		e1.ByteArrayField = tmp
	}

	if c5.Valid {
		tmp := c5.String
		e1.CharacterField = tmp
	}

	if c6.Valid {
		tmp := c6.String
		e1.CharacterFixedField = tmp
	}

	if c7.Valid {
		tmp := c7.IPNet
		e1.CidrField = tmp
	}

	if c8.Valid {
		tmp := c8.Int
		e1.DecimalField = tmp
	}

	if c9.Valid {
		tmp := c9.Float
		e1.DoublePrecisionField = tmp
	}

	if c10.Valid {
		tmp := c10.IPNet
		e1.InetField = tmp
	}

	if c11.Valid {
		tmp := c11.Elements
		e1.Int2Array = tmp
	}

	if c12.Valid {
		tmp := c12.Elements
		e1.Int4Array = tmp
	}

	if c13.Valid {
		tmp := c13.Elements
		e1.Int8Array = tmp
	}

	if c14.Valid {
		tmp := c14.Int
		e1.IntField = tmp
	}

	if c15.Valid {
		tmp := c15.Microseconds
		e1.IntervalField = tmp
	}

	if c16.Valid {
		tmp := c16.Bytes
		e1.JSONField = tmp
	}

	if c17.Valid {
		tmp := c17.Bytes
		e1.JsonbField = tmp
	}

	if c18.Valid {
		tmp := c18.Addr
		e1.MacaddrField = tmp
	}

	if c19.Valid {
		tmp := c19.Int
		e1.NumericField = tmp
	}

	if c20.Valid {
		tmp := c20.Float
		e1.RealField = tmp
	}

	if c21.Valid {
		tmp := c21.Int
		e1.SmallintField = tmp
	}

	if c22.Valid {
		tmp := c22.String
		e1.TextField = tmp
	}

	if c23.Valid {
		tmp := c23.Time
		e1.TimestampField = tmp
	}

	if c24.Valid {
		tmp := c24.Elements
		e1.UUIDArray = tmp
	}

	if c25.Valid {
		tmp := c25.Bytes
		e1.UUIDField = tmp
	}

	if c26.Valid {
		tmp := c26.Bool
		e2.BoolField = tmp
	}

	if c27.Valid {
		tmp := c27.Elements
		e2.Int4Array = tmp
	}

	if c28.Valid {
		tmp := c28.Elements
		e2.Int8Array = tmp
	}

	if c29.Valid {
		tmp := c29.String
		e2.TextField = tmp
	}

	if c30.Valid {
		tmp := c30.Time
		e2.TimestampField = tmp
	}

	if c31.Valid {
		tmp := c31.Elements
		e2.UUIDArray = tmp
	}

	if c32.Valid {
		tmp := c32.Bytes
		e2.UUIDField = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t comboScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t comboScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t comboScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewComboScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewComboScannerStaticRow(row *sql.Row) ComboScannerStaticRow {
	return ComboScannerStaticRow{
		row: row,
	}
}

// ComboScannerStaticRow generated by genieql
type ComboScannerStaticRow struct {
	row *sql.Row
}

// Scan generated by genieql
func (t ComboScannerStaticRow) Scan(e1 *Example1, e2 *Example2) error {
	var (
		c0  pgtype.Int8
		c1  pgtype.Bit
		c2  pgtype.Varbit
		c3  pgtype.Bool
		c4  pgtype.Bytea
		c5  pgtype.Varchar
		c6  pgtype.BPChar
		c7  pgtype.CIDR
		c8  pgtype.Numeric
		c9  pgtype.Float8
		c10 pgtype.Inet
		c11 pgtype.Int2Array
		c12 pgtype.Int4Array
		c13 pgtype.Int8Array
		c14 pgtype.Int4
		c15 pgtype.Interval
		c16 pgtype.JSON
		c17 pgtype.JSONB
		c18 pgtype.Macaddr
		c19 pgtype.Numeric
		c20 pgtype.Float4
		c21 pgtype.Int2
		c22 pgtype.Text
		c23 pgtype.Timestamptz
		c24 pgtype.UUIDArray
		c25 pgtype.UUID
		c26 pgtype.Bool
		c27 pgtype.Int4Array
		c28 pgtype.Int8Array
		c29 pgtype.Text
		c30 pgtype.Timestamptz
		c31 pgtype.UUIDArray
		c32 pgtype.UUID
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25, &c26, &c27, &c28, &c29, &c30, &c31, &c32); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Int
		e1.BigintField = tmp
	}

	if c1.Valid {
		tmp := c1.Bytes
		e1.BitField = tmp
	}

	if c2.Valid {
		tmp := c2.Bytes
		e1.BitVaryingField = tmp
	}

	if c3.Valid {
		tmp := c3.Bool
		e1.BoolField = tmp
	}

	if c4.Valid {
		tmp := c4.Bytes
		e1.ByteArrayField = tmp
	}

	if c5.Valid {
		tmp := c5.String
		e1.CharacterField = tmp
	}

	if c6.Valid {
		tmp := c6.String
		e1.CharacterFixedField = tmp
	}

	if c7.Valid {
		tmp := c7.IPNet
		e1.CidrField = tmp
	}

	if c8.Valid {
		tmp := c8.Int
		e1.DecimalField = tmp
	}

	if c9.Valid {
		tmp := c9.Float
		e1.DoublePrecisionField = tmp
	}

	if c10.Valid {
		tmp := c10.IPNet
		e1.InetField = tmp
	}

	if c11.Valid {
		tmp := c11.Elements
		e1.Int2Array = tmp
	}

	if c12.Valid {
		tmp := c12.Elements
		e1.Int4Array = tmp
	}

	if c13.Valid {
		tmp := c13.Elements
		e1.Int8Array = tmp
	}

	if c14.Valid {
		tmp := c14.Int
		e1.IntField = tmp
	}

	if c15.Valid {
		tmp := c15.Microseconds
		e1.IntervalField = tmp
	}

	if c16.Valid {
		tmp := c16.Bytes
		e1.JSONField = tmp
	}

	if c17.Valid {
		tmp := c17.Bytes
		e1.JsonbField = tmp
	}

	if c18.Valid {
		tmp := c18.Addr
		e1.MacaddrField = tmp
	}

	if c19.Valid {
		tmp := c19.Int
		e1.NumericField = tmp
	}

	if c20.Valid {
		tmp := c20.Float
		e1.RealField = tmp
	}

	if c21.Valid {
		tmp := c21.Int
		e1.SmallintField = tmp
	}

	if c22.Valid {
		tmp := c22.String
		e1.TextField = tmp
	}

	if c23.Valid {
		tmp := c23.Time
		e1.TimestampField = tmp
	}

	if c24.Valid {
		tmp := c24.Elements
		e1.UUIDArray = tmp
	}

	if c25.Valid {
		tmp := c25.Bytes
		e1.UUIDField = tmp
	}

	if c26.Valid {
		tmp := c26.Bool
		e2.BoolField = tmp
	}

	if c27.Valid {
		tmp := c27.Elements
		e2.Int4Array = tmp
	}

	if c28.Valid {
		tmp := c28.Elements
		e2.Int8Array = tmp
	}

	if c29.Valid {
		tmp := c29.String
		e2.TextField = tmp
	}

	if c30.Valid {
		tmp := c30.Time
		e2.TimestampField = tmp
	}

	if c31.Valid {
		tmp := c31.Elements
		e2.UUIDArray = tmp
	}

	if c32.Valid {
		tmp := c32.Bytes
		e2.UUIDField = tmp
	}

	return nil
}
