package definitions

import (
	"database/sql"
	"time"

	"github.com/lib/pq"
)

// DO NOT MODIFY: This File was auto generated by the following command:
// genieql generate experimental scanners types -o postgresql.scanners.gen.go
// invoked by go generate @ definitions/example.go line 9

const ProfileScannerStaticColumns = "i1,i2,b1,t1"

// ProfileScanner scanner interface.
type ProfileScanner interface {
	Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error
	Next() bool
	Close() error
	Err() error
}

type errProfileScanner struct {
	e error
}

func (t errProfileScanner) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	return t.e
}

func (t errProfileScanner) Next() bool {
	return false
}

func (t errProfileScanner) Err() error {
	return t.e
}

func (t errProfileScanner) Close() error {
	return nil
}

// StaticProfileScanner creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func StaticProfileScanner(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return staticProfileScanner{
		Rows: rows,
	}
}

type staticProfileScanner struct {
	Rows *sql.Rows
}

func (t staticProfileScanner) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 pq.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return t.Rows.Err()
}

func (t staticProfileScanner) Err() error {
	return t.Rows.Err()
}

func (t staticProfileScanner) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t staticProfileScanner) Next() bool {
	return t.Rows.Next()
}

// NewStaticRowProfileScanner creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewStaticRowProfileScanner(row *sql.Row) StaticRowProfileScanner {
	return StaticRowProfileScanner{
		row: row,
	}
}

type StaticRowProfileScanner struct {
	row *sql.Row
}

func (t StaticRowProfileScanner) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 pq.NullTime
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return nil
}

// DynamicProfileScanner creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func DynamicProfileScanner(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return dynamicProfileScanner{
		Rows: rows,
	}
}

type dynamicProfileScanner struct {
	Rows *sql.Rows
}

func (t dynamicProfileScanner) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullInt64
		c1      sql.NullInt64
		c2      sql.NullBool
		c3      pq.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case "i1":
			dst = append(dst, &c0)
		case "i2":
			dst = append(dst, &c1)
		case "b1":
			dst = append(dst, &c2)
		case "t1":
			dst = append(dst, &c3)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case "i1":
			if c0.Valid {
				tmp := int(c0.Int64)
				*i1 = tmp
			}
		case "i2":
			if c1.Valid {
				tmp := int(c1.Int64)
				*i2 = tmp
			}
		case "b1":
			if c2.Valid {
				tmp := c2.Bool
				*b1 = tmp
			}
		case "t1":
			if c3.Valid {
				tmp := c3.Time
				*t1 = tmp
			}
		}
	}

	return t.Rows.Err()
}

func (t dynamicProfileScanner) Err() error {
	return t.Rows.Err()
}

func (t dynamicProfileScanner) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t dynamicProfileScanner) Next() bool {
	return t.Rows.Next()
}

const Example1ScannerStaticColumns = "created_at,id,text_field,updated_at,uuid_field"

// Example1Scanner scanner interface.
type Example1Scanner interface {
	Scan(e *Example1) error
	Next() bool
	Close() error
	Err() error
}

type errExample1Scanner struct {
	e error
}

func (t errExample1Scanner) Scan(e *Example1) error {
	return t.e
}

func (t errExample1Scanner) Next() bool {
	return false
}

func (t errExample1Scanner) Err() error {
	return t.e
}

func (t errExample1Scanner) Close() error {
	return nil
}

// StaticExample1Scanner creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func StaticExample1Scanner(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return staticExample1Scanner{
		Rows: rows,
	}
}

type staticExample1Scanner struct {
	Rows *sql.Rows
}

func (t staticExample1Scanner) Scan(e *Example1) error {
	var (
		c0 pq.NullTime
		c1 sql.NullInt64
		c2 sql.NullString
		c3 pq.NullTime
		c4 sql.NullString
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		e.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		e.ID = tmp
	}

	if c2.Valid {
		tmp := c2.String
		e.TextField = &tmp
	}

	if c3.Valid {
		tmp := c3.Time
		e.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.String
		e.UUIDField = tmp
	}

	return t.Rows.Err()
}

func (t staticExample1Scanner) Err() error {
	return t.Rows.Err()
}

func (t staticExample1Scanner) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t staticExample1Scanner) Next() bool {
	return t.Rows.Next()
}

// NewStaticRowExample1Scanner creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewStaticRowExample1Scanner(row *sql.Row) StaticRowExample1Scanner {
	return StaticRowExample1Scanner{
		row: row,
	}
}

type StaticRowExample1Scanner struct {
	row *sql.Row
}

func (t StaticRowExample1Scanner) Scan(e *Example1) error {
	var (
		c0 pq.NullTime
		c1 sql.NullInt64
		c2 sql.NullString
		c3 pq.NullTime
		c4 sql.NullString
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		e.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		e.ID = tmp
	}

	if c2.Valid {
		tmp := c2.String
		e.TextField = &tmp
	}

	if c3.Valid {
		tmp := c3.Time
		e.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.String
		e.UUIDField = tmp
	}

	return nil
}

// DynamicExample1Scanner creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func DynamicExample1Scanner(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return dynamicExample1Scanner{
		Rows: rows,
	}
}

type dynamicExample1Scanner struct {
	Rows *sql.Rows
}

func (t dynamicExample1Scanner) Scan(e *Example1) error {
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pq.NullTime
		c1      sql.NullInt64
		c2      sql.NullString
		c3      pq.NullTime
		c4      sql.NullString
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case "created_at":
			dst = append(dst, &c0)
		case "id":
			dst = append(dst, &c1)
		case "text_field":
			dst = append(dst, &c2)
		case "updated_at":
			dst = append(dst, &c3)
		case "uuid_field":
			dst = append(dst, &c4)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case "created_at":
			if c0.Valid {
				tmp := c0.Time
				e.CreatedAt = tmp
			}
		case "id":
			if c1.Valid {
				tmp := int(c1.Int64)
				e.ID = tmp
			}
		case "text_field":
			if c2.Valid {
				tmp := c2.String
				e.TextField = &tmp
			}
		case "updated_at":
			if c3.Valid {
				tmp := c3.Time
				e.UpdatedAt = tmp
			}
		case "uuid_field":
			if c4.Valid {
				tmp := c4.String
				e.UUIDField = tmp
			}
		}
	}

	return t.Rows.Err()
}

func (t dynamicExample1Scanner) Err() error {
	return t.Rows.Err()
}

func (t dynamicExample1Scanner) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t dynamicExample1Scanner) Next() bool {
	return t.Rows.Next()
}

const ComboScannerStaticColumns = "created_at,id,text_field,updated_at,uuid_field,bool_field,created_at,text_field,updated_at,uuid_field"

// ComboScanner scanner interface.
type ComboScanner interface {
	Scan(e1 *Example1, e2 *Example2) error
	Next() bool
	Close() error
	Err() error
}

type errComboScanner struct {
	e error
}

func (t errComboScanner) Scan(e1 *Example1, e2 *Example2) error {
	return t.e
}

func (t errComboScanner) Next() bool {
	return false
}

func (t errComboScanner) Err() error {
	return t.e
}

func (t errComboScanner) Close() error {
	return nil
}

// StaticComboScanner creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func StaticComboScanner(rows *sql.Rows, err error) ComboScanner {
	if err != nil {
		return errComboScanner{e: err}
	}

	return staticComboScanner{
		Rows: rows,
	}
}

type staticComboScanner struct {
	Rows *sql.Rows
}

func (t staticComboScanner) Scan(e1 *Example1, e2 *Example2) error {
	var (
		c0 pq.NullTime
		c1 sql.NullInt64
		c2 sql.NullString
		c3 pq.NullTime
		c4 sql.NullString
		c5 sql.NullBool
		c6 pq.NullTime
		c7 sql.NullString
		c8 pq.NullTime
		c9 sql.NullString
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		e1.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		e1.ID = tmp
	}

	if c2.Valid {
		tmp := c2.String
		e1.TextField = &tmp
	}

	if c3.Valid {
		tmp := c3.Time
		e1.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.String
		e1.UUIDField = tmp
	}

	if c5.Valid {
		tmp := c5.Bool
		e2.BoolField = tmp
	}

	if c6.Valid {
		tmp := c6.Time
		e2.CreatedAt = tmp
	}

	if c7.Valid {
		tmp := c7.String
		e2.TextField = tmp
	}

	if c8.Valid {
		tmp := c8.Time
		e2.UpdatedAt = tmp
	}

	if c9.Valid {
		tmp := c9.String
		e2.UUIDField = tmp
	}

	return t.Rows.Err()
}

func (t staticComboScanner) Err() error {
	return t.Rows.Err()
}

func (t staticComboScanner) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t staticComboScanner) Next() bool {
	return t.Rows.Next()
}

// NewStaticRowComboScanner creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewStaticRowComboScanner(row *sql.Row) StaticRowComboScanner {
	return StaticRowComboScanner{
		row: row,
	}
}

type StaticRowComboScanner struct {
	row *sql.Row
}

func (t StaticRowComboScanner) Scan(e1 *Example1, e2 *Example2) error {
	var (
		c0 pq.NullTime
		c1 sql.NullInt64
		c2 sql.NullString
		c3 pq.NullTime
		c4 sql.NullString
		c5 sql.NullBool
		c6 pq.NullTime
		c7 sql.NullString
		c8 pq.NullTime
		c9 sql.NullString
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		e1.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		e1.ID = tmp
	}

	if c2.Valid {
		tmp := c2.String
		e1.TextField = &tmp
	}

	if c3.Valid {
		tmp := c3.Time
		e1.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.String
		e1.UUIDField = tmp
	}

	if c5.Valid {
		tmp := c5.Bool
		e2.BoolField = tmp
	}

	if c6.Valid {
		tmp := c6.Time
		e2.CreatedAt = tmp
	}

	if c7.Valid {
		tmp := c7.String
		e2.TextField = tmp
	}

	if c8.Valid {
		tmp := c8.Time
		e2.UpdatedAt = tmp
	}

	if c9.Valid {
		tmp := c9.String
		e2.UUIDField = tmp
	}

	return nil
}

// DynamicComboScanner creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func DynamicComboScanner(rows *sql.Rows, err error) ComboScanner {
	if err != nil {
		return errComboScanner{e: err}
	}

	return dynamicComboScanner{
		Rows: rows,
	}
}

type dynamicComboScanner struct {
	Rows *sql.Rows
}

func (t dynamicComboScanner) Scan(e1 *Example1, e2 *Example2) error {
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pq.NullTime
		c1      sql.NullInt64
		c2      sql.NullString
		c3      pq.NullTime
		c4      sql.NullString
		c5      sql.NullBool
		c6      pq.NullTime
		c7      sql.NullString
		c8      pq.NullTime
		c9      sql.NullString
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case "created_at":
			dst = append(dst, &c0)
		case "id":
			dst = append(dst, &c1)
		case "text_field":
			dst = append(dst, &c2)
		case "updated_at":
			dst = append(dst, &c3)
		case "uuid_field":
			dst = append(dst, &c4)
		case "bool_field":
			dst = append(dst, &c5)
		case "created_at":
			dst = append(dst, &c6)
		case "text_field":
			dst = append(dst, &c7)
		case "updated_at":
			dst = append(dst, &c8)
		case "uuid_field":
			dst = append(dst, &c9)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case "created_at":
			if c0.Valid {
				tmp := c0.Time
				e1.CreatedAt = tmp
			}
		case "id":
			if c1.Valid {
				tmp := int(c1.Int64)
				e1.ID = tmp
			}
		case "text_field":
			if c2.Valid {
				tmp := c2.String
				e1.TextField = &tmp
			}
		case "updated_at":
			if c3.Valid {
				tmp := c3.Time
				e1.UpdatedAt = tmp
			}
		case "uuid_field":
			if c4.Valid {
				tmp := c4.String
				e1.UUIDField = tmp
			}
		case "bool_field":
			if c5.Valid {
				tmp := c5.Bool
				e2.BoolField = tmp
			}
		case "created_at":
			if c6.Valid {
				tmp := c6.Time
				e2.CreatedAt = tmp
			}
		case "text_field":
			if c7.Valid {
				tmp := c7.String
				e2.TextField = tmp
			}
		case "updated_at":
			if c8.Valid {
				tmp := c8.Time
				e2.UpdatedAt = tmp
			}
		case "uuid_field":
			if c9.Valid {
				tmp := c9.String
				e2.UUIDField = tmp
			}
		}
	}

	return t.Rows.Err()
}

func (t dynamicComboScanner) Err() error {
	return t.Rows.Err()
}

func (t dynamicComboScanner) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t dynamicComboScanner) Next() bool {
	return t.Rows.Next()
}
