// +build !genieql.generated



package autocompile

import (
	"database/sql"
	"time"
)

// DO NOT MODIFY: This File was auto generated by the following command:
// genieql auto -o genieql.gen.go
// invoked by go generate @ autocompile/autocompile.go line 3

// Example1 structure generated by genieql.
type Example1 struct {
	CreatedAt time.Time
	ID        int
	TextField *string
	UpdatedAt time.Time
	UUIDField string
}

// Example2 structure generated by genieql.
type Example2 struct {
	BoolField bool
	CreatedAt time.Time
	TextField string
	UpdatedAt time.Time
	UUIDField string
}

// Example3 structure generated by genieql.
type Example3 struct {
	BoolField bool
	CreatedAt time.Time
	TextField string
	UpdatedAt time.Time
	UUIDField string
}

// CustomScanner scanner interface.
type CustomScanner interface {
	Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error
	Next() bool
	Close() error
	Err() error
}

type errCustomScanner struct {
	e error
}

func (t errCustomScanner) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	return t.e
}

func (t errCustomScanner) Next() bool {
	return false
}

func (t errCustomScanner) Err() error {
	return t.e
}

func (t errCustomScanner) Close() error {
	return nil
}

const CustomScannerStaticColumns = `"i1","i2","b1","t1"`

// NewCustomScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewCustomScannerStatic(rows *sql.Rows, err error) CustomScanner {
	if err != nil {
		return errCustomScanner{e: err}
	}

	return customScannerStatic{
		Rows: rows,
	}
}

type customScannerStatic struct {
	Rows *sql.Rows
}

func (t customScannerStatic) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return t.Rows.Err()
}

func (t customScannerStatic) Err() error {
	return t.Rows.Err()
}

func (t customScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t customScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewCustomScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewCustomScannerStaticRow(row *sql.Row) CustomScannerStaticRow {
	return CustomScannerStaticRow{
		row: row,
	}
}

type CustomScannerStaticRow struct {
	row *sql.Row
}

func (t CustomScannerStaticRow) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 sql.NullTime
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return nil
}

// NewCustomScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewCustomScannerDynamic(rows *sql.Rows, err error) CustomScanner {
	if err != nil {
		return errCustomScanner{e: err}
	}

	return customScannerDynamic{
		Rows: rows,
	}
}

type customScannerDynamic struct {
	Rows *sql.Rows
}

func (t customScannerDynamic) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	const (
		i10 = "i1"
		i21 = "i2"
		b12 = "b1"
		t13 = "t1"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullInt64
		c1      sql.NullInt64
		c2      sql.NullBool
		c3      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case i10:
			dst = append(dst, &c0)
		case i21:
			dst = append(dst, &c1)
		case b12:
			dst = append(dst, &c2)
		case t13:
			dst = append(dst, &c3)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case i10:
			if c0.Valid {
				tmp := int(c0.Int64)
				*i1 = tmp
			}
		case i21:
			if c1.Valid {
				tmp := int(c1.Int64)
				*i2 = tmp
			}
		case b12:
			if c2.Valid {
				tmp := c2.Bool
				*b1 = tmp
			}
		case t13:
			if c3.Valid {
				tmp := c3.Time
				*t1 = tmp
			}
		}
	}

	return t.Rows.Err()
}

func (t customScannerDynamic) Err() error {
	return t.Rows.Err()
}

func (t customScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t customScannerDynamic) Next() bool {
	return t.Rows.Next()
}


