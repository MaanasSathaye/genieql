package alternate1

import "database/sql"

// DO NOT MODIFY: This File was auto generated by the following command:
// genieql generate experimental scanners types --config=generators-test.config -o postgresql.scanners.gen.go
// invoked by go generate @ alternate1/10_genieql.go line 4

// Type1Scanner scanner interface.
type Type1Scanner interface {
	Scan(*Type1) error
	Next() bool
	Close() error
	Err() error
}

type errType1Scanner struct {
	e error
}

func (t errType1Scanner) Scan(*Type1) error {
	return t.e
}

func (t errType1Scanner) Next() bool {
	return false
}

func (t errType1Scanner) Err() error {
	return t.e
}

func (t errType1Scanner) Close() error {
	return nil
}

const Type1ScannerStaticColumns = `"field1","field2","field3","field4","field5","field6","field7","field8","unmappedfield"`

// NewType1ScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewType1ScannerStatic(rows *sql.Rows, err error) Type1Scanner {
	if err != nil {
		return errType1Scanner{e: err}
	}

	return type1ScannerStatic{
		Rows: rows,
	}
}

type type1ScannerStatic struct {
	Rows *sql.Rows
}

func (t type1ScannerStatic) Scan(*Type1) error {
	var ()

	if err := t.Rows.Scan(); err != nil {
		return err
	}

	return t.Rows.Err()
}

func (t type1ScannerStatic) Err() error {
	return t.Rows.Err()
}

func (t type1ScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t type1ScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewType1ScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewType1ScannerStaticRow(row *sql.Row) Type1ScannerStaticRow {
	return Type1ScannerStaticRow{
		row: row,
	}
}

type Type1ScannerStaticRow struct {
	row *sql.Row
}

func (t Type1ScannerStaticRow) Scan(*Type1) error {
	var ()

	if err := t.row.Scan(); err != nil {
		return err
	}

	return nil
}

// NewType1ScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewType1ScannerDynamic(rows *sql.Rows, err error) Type1Scanner {
	if err != nil {
		return errType1Scanner{e: err}
	}

	return type1ScannerDynamic{
		Rows: rows,
	}
}

type type1ScannerDynamic struct {
	Rows *sql.Rows
}

func (t type1ScannerDynamic) Scan(*Type1) error {
	const ()
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		}
	}

	return t.Rows.Err()
}

func (t type1ScannerDynamic) Err() error {
	return t.Rows.Err()
}

func (t type1ScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t type1ScannerDynamic) Next() bool {
	return t.Rows.Next()
}
