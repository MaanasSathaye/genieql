package alternate1

import (
	"database/sql"
	"time"

	"github.com/lib/pq"
)

// DO NOT MODIFY: This File was auto generated by the following command:
// genieql generate experimental scanners types --config=generators-test.config -o postgresql.scanners.gen.go
// invoked by go generate @ alternate1/10_genieql.go line 4

// Scanner1 scanner interface.
type Scanner1 interface {
	Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error
	Next() bool
	Close() error
	Err() error
}

type errScanner1 struct {
	e error
}

func (t errScanner1) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	return t.e
}

func (t errScanner1) Next() bool {
	return false
}

func (t errScanner1) Err() error {
	return t.e
}

func (t errScanner1) Close() error {
	return nil
}

const Scanner1StaticColumns = "i1,i2,b1,t1"

// NewScanner1Static creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewScanner1Static(rows *sql.Rows, err error) Scanner1 {
	if err != nil {
		return errScanner1{e: err}
	}

	return scanner1Static{
		Rows: rows,
	}
}

type scanner1Static struct {
	Rows *sql.Rows
}

func (t scanner1Static) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 pq.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return t.Rows.Err()
}

func (t scanner1Static) Err() error {
	return t.Rows.Err()
}

func (t scanner1Static) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t scanner1Static) Next() bool {
	return t.Rows.Next()
}

// NewScanner1StaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewScanner1StaticRow(row *sql.Row) Scanner1StaticRow {
	return Scanner1StaticRow{
		row: row,
	}
}

type Scanner1StaticRow struct {
	row *sql.Row
}

func (t Scanner1StaticRow) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullInt64
		c2 sql.NullBool
		c3 pq.NullTime
	)

	if err := t.row.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := int(c0.Int64)
		*i1 = tmp
	}

	if c1.Valid {
		tmp := int(c1.Int64)
		*i2 = tmp
	}

	if c2.Valid {
		tmp := c2.Bool
		*b1 = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		*t1 = tmp
	}

	return nil
}

// NewScanner1Dynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewScanner1Dynamic(rows *sql.Rows, err error) Scanner1 {
	if err != nil {
		return errScanner1{e: err}
	}

	return scanner1Dynamic{
		Rows: rows,
	}
}

type scanner1Dynamic struct {
	Rows *sql.Rows
}

func (t scanner1Dynamic) Scan(i1, i2 *int, b1 *bool, t1 *time.Time) error {
	const (
		i10 = "i1"
		i21 = "i2"
		b12 = "b1"
		t13 = "t1"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullInt64
		c1      sql.NullInt64
		c2      sql.NullBool
		c3      pq.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case i10:
			dst = append(dst, &c0)
		case i21:
			dst = append(dst, &c1)
		case b12:
			dst = append(dst, &c2)
		case t13:
			dst = append(dst, &c3)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case i10:
			if c0.Valid {
				tmp := int(c0.Int64)
				*i1 = tmp
			}
		case i21:
			if c1.Valid {
				tmp := int(c1.Int64)
				*i2 = tmp
			}
		case b12:
			if c2.Valid {
				tmp := c2.Bool
				*b1 = tmp
			}
		case t13:
			if c3.Valid {
				tmp := c3.Time
				*t1 = tmp
			}
		}
	}

	return t.Rows.Err()
}

func (t scanner1Dynamic) Err() error {
	return t.Rows.Err()
}

func (t scanner1Dynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

func (t scanner1Dynamic) Next() bool {
	return t.Rows.Next()
}
