package scanners

import (
	"database/sql"

	"bitbucket.org/jatone/genieql/generators/internal/scanners/alternate1"
	"bitbucket.org/jatone/genieql/generators/internal/scanners/alternate2"
	"github.com/jackc/pgtype"
)

// DO NOT MODIFY: This File was auto generated by the following command:
// genieql generate experimental scanners types --config=generators-test.config -o postgresql.scanners.gen.go
// invoked by go generate @ scanners/type1.go line 6

// ComboScanner scanner interface.
type ComboScanner interface {
	Scan(t1 *alternate1.Type1, t2 *alternate2.Type1, t3 *Type1) error
	Next() bool
	Close() error
	Err() error
}

type errComboScanner struct {
	e error
}

func (t errComboScanner) Scan(t1 *alternate1.Type1, t2 *alternate2.Type1, t3 *Type1) error {
	return t.e
}

func (t errComboScanner) Next() bool {
	return false
}

func (t errComboScanner) Err() error {
	return t.e
}

func (t errComboScanner) Close() error {
	return nil
}

// NewComboScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewComboScannerStatic(rows *sql.Rows, err error) ComboScanner {
	if err != nil {
		return errComboScanner{e: err}
	}

	return comboScannerStatic{
		Rows: rows,
	}
}

// comboScannerStatic generated by genieql
type comboScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t comboScannerStatic) Scan(t1 *alternate1.Type1, t2 *alternate2.Type1, t3 *Type1) error {
	var (
		c0  pgtype.Text
		c1  pgtype.Text
		c2  pgtype.Bool
		c3  pgtype.Bool
		c4  pgtype.Int4
		c5  pgtype.Int4
		c6  pgtype.Timestamptz
		c7  pgtype.Timestamptz
		c8  pgtype.Int4
		c9  pgtype.Text
		c10 pgtype.Text
		c11 pgtype.Bool
		c12 pgtype.Bool
		c13 pgtype.Int4
		c14 pgtype.Int4
		c15 pgtype.Timestamptz
		c16 pgtype.Timestamptz
		c17 pgtype.Int4
		c18 sql.NullString
		c19 sql.NullString
		c20 sql.NullBool
		c21 sql.NullBool
		c22 sql.NullInt64
		c23 sql.NullInt64
		c24 sql.NullTime
		c25 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25); err != nil {
		return err
	}

	if err := c0.AssignTo(&t1.Field1); err != nil {
		return err
	}

	if err := c1.AssignTo(&t1.Field2); err != nil {
		return err
	}

	if err := c2.AssignTo(&t1.Field3); err != nil {
		return err
	}

	if err := c3.AssignTo(&t1.Field4); err != nil {
		return err
	}

	if err := c4.AssignTo(&t1.Field5); err != nil {
		return err
	}

	if err := c5.AssignTo(&t1.Field6); err != nil {
		return err
	}

	if err := c6.AssignTo(&t1.Field7); err != nil {
		return err
	}

	if err := c7.AssignTo(&t1.Field8); err != nil {
		return err
	}

	if err := c8.AssignTo(&t1.Unmappedfield); err != nil {
		return err
	}

	if err := c9.AssignTo(&t2.Field1); err != nil {
		return err
	}

	if err := c10.AssignTo(&t2.Field2); err != nil {
		return err
	}

	if err := c11.AssignTo(&t2.Field3); err != nil {
		return err
	}

	if err := c12.AssignTo(&t2.Field4); err != nil {
		return err
	}

	if err := c13.AssignTo(&t2.Field5); err != nil {
		return err
	}

	if err := c14.AssignTo(&t2.Field6); err != nil {
		return err
	}

	if err := c15.AssignTo(&t2.Field7); err != nil {
		return err
	}

	if err := c16.AssignTo(&t2.Field8); err != nil {
		return err
	}

	if err := c17.AssignTo(&t2.Unmappedfield); err != nil {
		return err
	}

	if c18.Valid {
		tmp := c18.String
		t3.Field1 = tmp
	}

	if c19.Valid {
		tmp := c19.String
		*t3.Field2 = tmp
	}

	if c20.Valid {
		tmp := c20.Bool
		t3.Field3 = tmp
	}

	if c21.Valid {
		tmp := c21.Bool
		*t3.Field4 = tmp
	}

	if c22.Valid {
		tmp := int(c22.Int64)
		t3.Field5 = tmp
	}

	if c23.Valid {
		tmp := int(c23.Int64)
		*t3.Field6 = tmp
	}

	if c24.Valid {
		tmp := c24.Time
		t3.Field7 = tmp
	}

	if c25.Valid {
		tmp := c25.Time
		*t3.Field8 = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t comboScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t comboScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t comboScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewComboScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewComboScannerStaticRow(row *sql.Row, err error) ComboScannerStaticRow {
	return ComboScannerStaticRow{
		err: err,
		row: row,
	}
}

// ComboScannerStaticRow generated by genieql
type ComboScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t ComboScannerStaticRow) Scan(t1 *alternate1.Type1, t2 *alternate2.Type1, t3 *Type1) error {
	var (
		c0  pgtype.Text
		c1  pgtype.Text
		c2  pgtype.Bool
		c3  pgtype.Bool
		c4  pgtype.Int4
		c5  pgtype.Int4
		c6  pgtype.Timestamptz
		c7  pgtype.Timestamptz
		c8  pgtype.Int4
		c9  pgtype.Text
		c10 pgtype.Text
		c11 pgtype.Bool
		c12 pgtype.Bool
		c13 pgtype.Int4
		c14 pgtype.Int4
		c15 pgtype.Timestamptz
		c16 pgtype.Timestamptz
		c17 pgtype.Int4
		c18 sql.NullString
		c19 sql.NullString
		c20 sql.NullBool
		c21 sql.NullBool
		c22 sql.NullInt64
		c23 sql.NullInt64
		c24 sql.NullTime
		c25 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25); err != nil {
		return err
	}

	if err := c0.AssignTo(&t1.Field1); err != nil {
		return err
	}

	if err := c1.AssignTo(&t1.Field2); err != nil {
		return err
	}

	if err := c2.AssignTo(&t1.Field3); err != nil {
		return err
	}

	if err := c3.AssignTo(&t1.Field4); err != nil {
		return err
	}

	if err := c4.AssignTo(&t1.Field5); err != nil {
		return err
	}

	if err := c5.AssignTo(&t1.Field6); err != nil {
		return err
	}

	if err := c6.AssignTo(&t1.Field7); err != nil {
		return err
	}

	if err := c7.AssignTo(&t1.Field8); err != nil {
		return err
	}

	if err := c8.AssignTo(&t1.Unmappedfield); err != nil {
		return err
	}

	if err := c9.AssignTo(&t2.Field1); err != nil {
		return err
	}

	if err := c10.AssignTo(&t2.Field2); err != nil {
		return err
	}

	if err := c11.AssignTo(&t2.Field3); err != nil {
		return err
	}

	if err := c12.AssignTo(&t2.Field4); err != nil {
		return err
	}

	if err := c13.AssignTo(&t2.Field5); err != nil {
		return err
	}

	if err := c14.AssignTo(&t2.Field6); err != nil {
		return err
	}

	if err := c15.AssignTo(&t2.Field7); err != nil {
		return err
	}

	if err := c16.AssignTo(&t2.Field8); err != nil {
		return err
	}

	if err := c17.AssignTo(&t2.Unmappedfield); err != nil {
		return err
	}

	if c18.Valid {
		tmp := c18.String
		t3.Field1 = tmp
	}

	if c19.Valid {
		tmp := c19.String
		*t3.Field2 = tmp
	}

	if c20.Valid {
		tmp := c20.Bool
		t3.Field3 = tmp
	}

	if c21.Valid {
		tmp := c21.Bool
		*t3.Field4 = tmp
	}

	if c22.Valid {
		tmp := int(c22.Int64)
		t3.Field5 = tmp
	}

	if c23.Valid {
		tmp := int(c23.Int64)
		*t3.Field6 = tmp
	}

	if c24.Valid {
		tmp := c24.Time
		t3.Field7 = tmp
	}

	if c25.Valid {
		tmp := c25.Time
		*t3.Field8 = tmp
	}

	return nil
}
