package functions

import (
	"database/sql"
	"math"
	"time"

	"github.com/jackc/pgtype"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql generate experimental scanners types -o postgresql.scanners.gen.go
// invoked by go generate @ functions/functions.go line 4

// Example1Scanner scanner interface.
type Example1Scanner interface {
	Scan(e *Example1) error
	Next() bool
	Close() error
	Err() error
}

type errExample1Scanner struct {
	e error
}

func (t errExample1Scanner) Scan(e *Example1) error {
	return t.e
}

func (t errExample1Scanner) Next() bool {
	return false
}

func (t errExample1Scanner) Err() error {
	return t.e
}

func (t errExample1Scanner) Close() error {
	return nil
}

// Example1ScannerStaticColumns generated by genieql
const Example1ScannerStaticColumns = `"bigint_field","bit_field","bit_varying_field","bool_field","byte_array_field","character_field","character_fixed_field","cidr_field","decimal_field","double_precision_field","inet_field","int2_array","int4_array","int8_array","int_field","interval_field","json_field","jsonb_field","macaddr_field","numeric_field","real_field","smallint_field","text_field","timestamp_field","uuid_array","uuid_field"`

// NewExample1ScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewExample1ScannerStatic(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return example1ScannerStatic{
		Rows: rows,
	}
}

// example1ScannerStatic generated by genieql
type example1ScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example1ScannerStatic) Scan(e *Example1) error {
	var (
		c0  pgtype.Int8
		c1  pgtype.Bit
		c2  pgtype.Varbit
		c3  pgtype.Bool
		c4  pgtype.Bytea
		c5  pgtype.Varchar
		c6  pgtype.BPChar
		c7  pgtype.CIDR
		c8  pgtype.Numeric
		c9  pgtype.Float8
		c10 pgtype.Inet
		c11 pgtype.Int2Array
		c12 pgtype.Int4Array
		c13 pgtype.Int8Array
		c14 pgtype.Int4
		c15 pgtype.Interval
		c16 pgtype.JSON
		c17 pgtype.JSONB
		c18 pgtype.Macaddr
		c19 pgtype.Numeric
		c20 pgtype.Float4
		c21 pgtype.Int2
		c22 pgtype.Text
		c23 pgtype.Timestamptz
		c24 pgtype.UUIDArray
		c25 pgtype.UUID
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25); err != nil {
		return err
	}

	if err := c0.AssignTo(&e.BigintField); err != nil {
		return err
	}

	if err := c1.AssignTo(&e.BitField); err != nil {
		return err
	}

	if err := c2.AssignTo(&e.BitVaryingField); err != nil {
		return err
	}

	if err := c3.AssignTo(&e.BoolField); err != nil {
		return err
	}

	if err := c4.AssignTo(&e.ByteArrayField); err != nil {
		return err
	}

	if err := c5.AssignTo(&e.CharacterField); err != nil {
		return err
	}

	if err := c6.AssignTo(&e.CharacterFixedField); err != nil {
		return err
	}

	if err := c7.AssignTo(&e.CidrField); err != nil {
		return err
	}

	if err := c8.AssignTo(&e.DecimalField); err != nil {
		return err
	}

	if err := c9.AssignTo(&e.DoublePrecisionField); err != nil {
		return err
	}

	if err := c10.AssignTo(&e.InetField); err != nil {
		return err
	}

	if err := c11.AssignTo(&e.Int2Array); err != nil {
		return err
	}

	if err := c12.AssignTo(&e.Int4Array); err != nil {
		return err
	}

	if err := c13.AssignTo(&e.Int8Array); err != nil {
		return err
	}

	if err := c14.AssignTo(&e.IntField); err != nil {
		return err
	}

	if err := c15.AssignTo(&e.IntervalField); err != nil {
		return err
	}

	if err := c16.AssignTo(&e.JSONField); err != nil {
		return err
	}

	if err := c17.AssignTo(&e.JsonbField); err != nil {
		return err
	}

	if err := c18.AssignTo(&e.MacaddrField); err != nil {
		return err
	}

	if err := c19.AssignTo(&e.NumericField); err != nil {
		return err
	}

	if err := c20.AssignTo(&e.RealField); err != nil {
		return err
	}

	if err := c21.AssignTo(&e.SmallintField); err != nil {
		return err
	}

	if err := c22.AssignTo(&e.TextField); err != nil {
		return err
	}

	switch c23.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.TimestampField = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.TimestampField = tmp
	default:
		if err := c23.AssignTo(&e.TimestampField); err != nil {
			return err
		}
	}

	if err := c24.AssignTo(&e.UUIDArray); err != nil {
		return err
	}

	if err := c25.AssignTo(&e.UUIDField); err != nil {
		return err
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example1ScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example1ScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example1ScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewExample1ScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewExample1ScannerStaticRow(row *sql.Row) Example1ScannerStaticRow {
	return Example1ScannerStaticRow{
		row: row,
	}
}

// Example1ScannerStaticRow generated by genieql
type Example1ScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t Example1ScannerStaticRow) Scan(e *Example1) error {
	var (
		c0  pgtype.Int8
		c1  pgtype.Bit
		c2  pgtype.Varbit
		c3  pgtype.Bool
		c4  pgtype.Bytea
		c5  pgtype.Varchar
		c6  pgtype.BPChar
		c7  pgtype.CIDR
		c8  pgtype.Numeric
		c9  pgtype.Float8
		c10 pgtype.Inet
		c11 pgtype.Int2Array
		c12 pgtype.Int4Array
		c13 pgtype.Int8Array
		c14 pgtype.Int4
		c15 pgtype.Interval
		c16 pgtype.JSON
		c17 pgtype.JSONB
		c18 pgtype.Macaddr
		c19 pgtype.Numeric
		c20 pgtype.Float4
		c21 pgtype.Int2
		c22 pgtype.Text
		c23 pgtype.Timestamptz
		c24 pgtype.UUIDArray
		c25 pgtype.UUID
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25); err != nil {
		return err
	}

	if err := c0.AssignTo(&e.BigintField); err != nil {
		return err
	}

	if err := c1.AssignTo(&e.BitField); err != nil {
		return err
	}

	if err := c2.AssignTo(&e.BitVaryingField); err != nil {
		return err
	}

	if err := c3.AssignTo(&e.BoolField); err != nil {
		return err
	}

	if err := c4.AssignTo(&e.ByteArrayField); err != nil {
		return err
	}

	if err := c5.AssignTo(&e.CharacterField); err != nil {
		return err
	}

	if err := c6.AssignTo(&e.CharacterFixedField); err != nil {
		return err
	}

	if err := c7.AssignTo(&e.CidrField); err != nil {
		return err
	}

	if err := c8.AssignTo(&e.DecimalField); err != nil {
		return err
	}

	if err := c9.AssignTo(&e.DoublePrecisionField); err != nil {
		return err
	}

	if err := c10.AssignTo(&e.InetField); err != nil {
		return err
	}

	if err := c11.AssignTo(&e.Int2Array); err != nil {
		return err
	}

	if err := c12.AssignTo(&e.Int4Array); err != nil {
		return err
	}

	if err := c13.AssignTo(&e.Int8Array); err != nil {
		return err
	}

	if err := c14.AssignTo(&e.IntField); err != nil {
		return err
	}

	if err := c15.AssignTo(&e.IntervalField); err != nil {
		return err
	}

	if err := c16.AssignTo(&e.JSONField); err != nil {
		return err
	}

	if err := c17.AssignTo(&e.JsonbField); err != nil {
		return err
	}

	if err := c18.AssignTo(&e.MacaddrField); err != nil {
		return err
	}

	if err := c19.AssignTo(&e.NumericField); err != nil {
		return err
	}

	if err := c20.AssignTo(&e.RealField); err != nil {
		return err
	}

	if err := c21.AssignTo(&e.SmallintField); err != nil {
		return err
	}

	if err := c22.AssignTo(&e.TextField); err != nil {
		return err
	}

	switch c23.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.TimestampField = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.TimestampField = tmp
	default:
		if err := c23.AssignTo(&e.TimestampField); err != nil {
			return err
		}
	}

	if err := c24.AssignTo(&e.UUIDArray); err != nil {
		return err
	}

	if err := c25.AssignTo(&e.UUIDField); err != nil {
		return err
	}

	return nil
}

// Err set an error to return by scan
func (t Example1ScannerStaticRow) Err(err error) Example1ScannerStaticRow {
	t.err = err
	return t
}

// NewExample1ScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewExample1ScannerDynamic(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return example1ScannerDynamic{
		Rows: rows,
	}
}

// example1ScannerDynamic generated by genieql
type example1ScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example1ScannerDynamic) Scan(e *Example1) error {
	const (
		cn0  = "bigint_field"
		cn1  = "bit_field"
		cn2  = "bit_varying_field"
		cn3  = "bool_field"
		cn4  = "byte_array_field"
		cn5  = "character_field"
		cn6  = "character_fixed_field"
		cn7  = "cidr_field"
		cn8  = "decimal_field"
		cn9  = "double_precision_field"
		cn10 = "inet_field"
		cn11 = "int2_array"
		cn12 = "int4_array"
		cn13 = "int8_array"
		cn14 = "int_field"
		cn15 = "interval_field"
		cn16 = "json_field"
		cn17 = "jsonb_field"
		cn18 = "macaddr_field"
		cn19 = "numeric_field"
		cn20 = "real_field"
		cn21 = "smallint_field"
		cn22 = "text_field"
		cn23 = "timestamp_field"
		cn24 = "uuid_array"
		cn25 = "uuid_field"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pgtype.Int8
		c1      pgtype.Bit
		c2      pgtype.Varbit
		c3      pgtype.Bool
		c4      pgtype.Bytea
		c5      pgtype.Varchar
		c6      pgtype.BPChar
		c7      pgtype.CIDR
		c8      pgtype.Numeric
		c9      pgtype.Float8
		c10     pgtype.Inet
		c11     pgtype.Int2Array
		c12     pgtype.Int4Array
		c13     pgtype.Int8Array
		c14     pgtype.Int4
		c15     pgtype.Interval
		c16     pgtype.JSON
		c17     pgtype.JSONB
		c18     pgtype.Macaddr
		c19     pgtype.Numeric
		c20     pgtype.Float4
		c21     pgtype.Int2
		c22     pgtype.Text
		c23     pgtype.Timestamptz
		c24     pgtype.UUIDArray
		c25     pgtype.UUID
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		case cn12:
			dst = append(dst, &c12)
		case cn13:
			dst = append(dst, &c13)
		case cn14:
			dst = append(dst, &c14)
		case cn15:
			dst = append(dst, &c15)
		case cn16:
			dst = append(dst, &c16)
		case cn17:
			dst = append(dst, &c17)
		case cn18:
			dst = append(dst, &c18)
		case cn19:
			dst = append(dst, &c19)
		case cn20:
			dst = append(dst, &c20)
		case cn21:
			dst = append(dst, &c21)
		case cn22:
			dst = append(dst, &c22)
		case cn23:
			dst = append(dst, &c23)
		case cn24:
			dst = append(dst, &c24)
		case cn25:
			dst = append(dst, &c25)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if err := c0.AssignTo(&e.BigintField); err != nil {
				return err
			}
		case cn1:
			if err := c1.AssignTo(&e.BitField); err != nil {
				return err
			}
		case cn2:
			if err := c2.AssignTo(&e.BitVaryingField); err != nil {
				return err
			}
		case cn3:
			if err := c3.AssignTo(&e.BoolField); err != nil {
				return err
			}
		case cn4:
			if err := c4.AssignTo(&e.ByteArrayField); err != nil {
				return err
			}
		case cn5:
			if err := c5.AssignTo(&e.CharacterField); err != nil {
				return err
			}
		case cn6:
			if err := c6.AssignTo(&e.CharacterFixedField); err != nil {
				return err
			}
		case cn7:
			if err := c7.AssignTo(&e.CidrField); err != nil {
				return err
			}
		case cn8:
			if err := c8.AssignTo(&e.DecimalField); err != nil {
				return err
			}
		case cn9:
			if err := c9.AssignTo(&e.DoublePrecisionField); err != nil {
				return err
			}
		case cn10:
			if err := c10.AssignTo(&e.InetField); err != nil {
				return err
			}
		case cn11:
			if err := c11.AssignTo(&e.Int2Array); err != nil {
				return err
			}
		case cn12:
			if err := c12.AssignTo(&e.Int4Array); err != nil {
				return err
			}
		case cn13:
			if err := c13.AssignTo(&e.Int8Array); err != nil {
				return err
			}
		case cn14:
			if err := c14.AssignTo(&e.IntField); err != nil {
				return err
			}
		case cn15:
			if err := c15.AssignTo(&e.IntervalField); err != nil {
				return err
			}
		case cn16:
			if err := c16.AssignTo(&e.JSONField); err != nil {
				return err
			}
		case cn17:
			if err := c17.AssignTo(&e.JsonbField); err != nil {
				return err
			}
		case cn18:
			if err := c18.AssignTo(&e.MacaddrField); err != nil {
				return err
			}
		case cn19:
			if err := c19.AssignTo(&e.NumericField); err != nil {
				return err
			}
		case cn20:
			if err := c20.AssignTo(&e.RealField); err != nil {
				return err
			}
		case cn21:
			if err := c21.AssignTo(&e.SmallintField); err != nil {
				return err
			}
		case cn22:
			if err := c22.AssignTo(&e.TextField); err != nil {
				return err
			}
		case cn23:
			switch c23.InfinityModifier {
			case pgtype.Infinity:
				tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
				e.TimestampField = tmp
			case pgtype.NegativeInfinity:
				tmp := time.Unix(math.MinInt64, math.MinInt64)
				e.TimestampField = tmp
			default:
				if err := c23.AssignTo(&e.TimestampField); err != nil {
					return err
				}
			}
		case cn24:
			if err := c24.AssignTo(&e.UUIDArray); err != nil {
				return err
			}
		case cn25:
			if err := c25.AssignTo(&e.UUIDField); err != nil {
				return err
			}
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example1ScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example1ScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example1ScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// Example2Scanner scanner interface.
type Example2Scanner interface {
	Scan(e *Example2) error
	Next() bool
	Close() error
	Err() error
}

type errExample2Scanner struct {
	e error
}

func (t errExample2Scanner) Scan(e *Example2) error {
	return t.e
}

func (t errExample2Scanner) Next() bool {
	return false
}

func (t errExample2Scanner) Err() error {
	return t.e
}

func (t errExample2Scanner) Close() error {
	return nil
}

// Example2ScannerStaticColumns generated by genieql
const Example2ScannerStaticColumns = `"bool_field","int4_array","int8_array","text_field","timestamp_field","uuid_array","uuid_field"`

// NewExample2ScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewExample2ScannerStatic(rows *sql.Rows, err error) Example2Scanner {
	if err != nil {
		return errExample2Scanner{e: err}
	}

	return example2ScannerStatic{
		Rows: rows,
	}
}

// example2ScannerStatic generated by genieql
type example2ScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example2ScannerStatic) Scan(e *Example2) error {
	var (
		c0 pgtype.Bool
		c1 pgtype.Int4Array
		c2 pgtype.Int8Array
		c3 pgtype.Text
		c4 pgtype.Timestamptz
		c5 pgtype.UUIDArray
		c6 pgtype.UUID
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6); err != nil {
		return err
	}

	if err := c0.AssignTo(&e.BoolField); err != nil {
		return err
	}

	if err := c1.AssignTo(&e.Int4Array); err != nil {
		return err
	}

	if err := c2.AssignTo(&e.Int8Array); err != nil {
		return err
	}

	if err := c3.AssignTo(&e.TextField); err != nil {
		return err
	}

	switch c4.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.TimestampField = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.TimestampField = tmp
	default:
		if err := c4.AssignTo(&e.TimestampField); err != nil {
			return err
		}
	}

	if err := c5.AssignTo(&e.UUIDArray); err != nil {
		return err
	}

	if err := c6.AssignTo(&e.UUIDField); err != nil {
		return err
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example2ScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example2ScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example2ScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewExample2ScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewExample2ScannerStaticRow(row *sql.Row) Example2ScannerStaticRow {
	return Example2ScannerStaticRow{
		row: row,
	}
}

// Example2ScannerStaticRow generated by genieql
type Example2ScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t Example2ScannerStaticRow) Scan(e *Example2) error {
	var (
		c0 pgtype.Bool
		c1 pgtype.Int4Array
		c2 pgtype.Int8Array
		c3 pgtype.Text
		c4 pgtype.Timestamptz
		c5 pgtype.UUIDArray
		c6 pgtype.UUID
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6); err != nil {
		return err
	}

	if err := c0.AssignTo(&e.BoolField); err != nil {
		return err
	}

	if err := c1.AssignTo(&e.Int4Array); err != nil {
		return err
	}

	if err := c2.AssignTo(&e.Int8Array); err != nil {
		return err
	}

	if err := c3.AssignTo(&e.TextField); err != nil {
		return err
	}

	switch c4.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.TimestampField = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.TimestampField = tmp
	default:
		if err := c4.AssignTo(&e.TimestampField); err != nil {
			return err
		}
	}

	if err := c5.AssignTo(&e.UUIDArray); err != nil {
		return err
	}

	if err := c6.AssignTo(&e.UUIDField); err != nil {
		return err
	}

	return nil
}

// Err set an error to return by scan
func (t Example2ScannerStaticRow) Err(err error) Example2ScannerStaticRow {
	t.err = err
	return t
}

// NewExample2ScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewExample2ScannerDynamic(rows *sql.Rows, err error) Example2Scanner {
	if err != nil {
		return errExample2Scanner{e: err}
	}

	return example2ScannerDynamic{
		Rows: rows,
	}
}

// example2ScannerDynamic generated by genieql
type example2ScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example2ScannerDynamic) Scan(e *Example2) error {
	const (
		cn0 = "bool_field"
		cn1 = "int4_array"
		cn2 = "int8_array"
		cn3 = "text_field"
		cn4 = "timestamp_field"
		cn5 = "uuid_array"
		cn6 = "uuid_field"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pgtype.Bool
		c1      pgtype.Int4Array
		c2      pgtype.Int8Array
		c3      pgtype.Text
		c4      pgtype.Timestamptz
		c5      pgtype.UUIDArray
		c6      pgtype.UUID
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if err := c0.AssignTo(&e.BoolField); err != nil {
				return err
			}
		case cn1:
			if err := c1.AssignTo(&e.Int4Array); err != nil {
				return err
			}
		case cn2:
			if err := c2.AssignTo(&e.Int8Array); err != nil {
				return err
			}
		case cn3:
			if err := c3.AssignTo(&e.TextField); err != nil {
				return err
			}
		case cn4:
			switch c4.InfinityModifier {
			case pgtype.Infinity:
				tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
				e.TimestampField = tmp
			case pgtype.NegativeInfinity:
				tmp := time.Unix(math.MinInt64, math.MinInt64)
				e.TimestampField = tmp
			default:
				if err := c4.AssignTo(&e.TimestampField); err != nil {
					return err
				}
			}
		case cn5:
			if err := c5.AssignTo(&e.UUIDArray); err != nil {
				return err
			}
		case cn6:
			if err := c6.AssignTo(&e.UUIDField); err != nil {
				return err
			}
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example2ScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example2ScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example2ScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// Example3Scanner scanner interface.
type Example3Scanner interface {
	Scan(e *Example3) error
	Next() bool
	Close() error
	Err() error
}

type errExample3Scanner struct {
	e error
}

func (t errExample3Scanner) Scan(e *Example3) error {
	return t.e
}

func (t errExample3Scanner) Next() bool {
	return false
}

func (t errExample3Scanner) Err() error {
	return t.e
}

func (t errExample3Scanner) Close() error {
	return nil
}

// Example3ScannerStaticColumns generated by genieql
const Example3ScannerStaticColumns = `"created","email","id","updated"`

// NewExample3ScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewExample3ScannerStatic(rows *sql.Rows, err error) Example3Scanner {
	if err != nil {
		return errExample3Scanner{e: err}
	}

	return example3ScannerStatic{
		Rows: rows,
	}
}

// example3ScannerStatic generated by genieql
type example3ScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example3ScannerStatic) Scan(e *Example3) error {
	var (
		c0 pgtype.Timestamptz
		c1 pgtype.Text
		c2 pgtype.Int8
		c3 pgtype.Timestamptz
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	switch c0.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.Created = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.Created = tmp
	default:
		if err := c0.AssignTo(&e.Created); err != nil {
			return err
		}
	}

	if err := c1.AssignTo(&e.Email); err != nil {
		return err
	}

	if err := c2.AssignTo(&e.ID); err != nil {
		return err
	}

	switch c3.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.Updated = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.Updated = tmp
	default:
		if err := c3.AssignTo(&e.Updated); err != nil {
			return err
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example3ScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example3ScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example3ScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewExample3ScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewExample3ScannerStaticRow(row *sql.Row) Example3ScannerStaticRow {
	return Example3ScannerStaticRow{
		row: row,
	}
}

// Example3ScannerStaticRow generated by genieql
type Example3ScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t Example3ScannerStaticRow) Scan(e *Example3) error {
	var (
		c0 pgtype.Timestamptz
		c1 pgtype.Text
		c2 pgtype.Int8
		c3 pgtype.Timestamptz
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	switch c0.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.Created = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.Created = tmp
	default:
		if err := c0.AssignTo(&e.Created); err != nil {
			return err
		}
	}

	if err := c1.AssignTo(&e.Email); err != nil {
		return err
	}

	if err := c2.AssignTo(&e.ID); err != nil {
		return err
	}

	switch c3.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.Updated = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.Updated = tmp
	default:
		if err := c3.AssignTo(&e.Updated); err != nil {
			return err
		}
	}

	return nil
}

// Err set an error to return by scan
func (t Example3ScannerStaticRow) Err(err error) Example3ScannerStaticRow {
	t.err = err
	return t
}

// NewExample3ScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewExample3ScannerDynamic(rows *sql.Rows, err error) Example3Scanner {
	if err != nil {
		return errExample3Scanner{e: err}
	}

	return example3ScannerDynamic{
		Rows: rows,
	}
}

// example3ScannerDynamic generated by genieql
type example3ScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example3ScannerDynamic) Scan(e *Example3) error {
	const (
		cn0 = "created"
		cn1 = "email"
		cn2 = "id"
		cn3 = "updated"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pgtype.Timestamptz
		c1      pgtype.Text
		c2      pgtype.Int8
		c3      pgtype.Timestamptz
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			switch c0.InfinityModifier {
			case pgtype.Infinity:
				tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
				e.Created = tmp
			case pgtype.NegativeInfinity:
				tmp := time.Unix(math.MinInt64, math.MinInt64)
				e.Created = tmp
			default:
				if err := c0.AssignTo(&e.Created); err != nil {
					return err
				}
			}
		case cn1:
			if err := c1.AssignTo(&e.Email); err != nil {
				return err
			}
		case cn2:
			if err := c2.AssignTo(&e.ID); err != nil {
				return err
			}
		case cn3:
			switch c3.InfinityModifier {
			case pgtype.Infinity:
				tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
				e.Updated = tmp
			case pgtype.NegativeInfinity:
				tmp := time.Unix(math.MinInt64, math.MinInt64)
				e.Updated = tmp
			default:
				if err := c3.AssignTo(&e.Updated); err != nil {
					return err
				}
			}
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example3ScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example3ScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example3ScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// Example4Scanner scanner interface.
type Example4Scanner interface {
	Scan(e *Example4) error
	Next() bool
	Close() error
	Err() error
}

type errExample4Scanner struct {
	e error
}

func (t errExample4Scanner) Scan(e *Example4) error {
	return t.e
}

func (t errExample4Scanner) Next() bool {
	return false
}

func (t errExample4Scanner) Err() error {
	return t.e
}

func (t errExample4Scanner) Close() error {
	return nil
}

// Example4ScannerStaticColumns generated by genieql
const Example4ScannerStaticColumns = `"created","email","id","updated"`

// NewExample4ScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewExample4ScannerStatic(rows *sql.Rows, err error) Example4Scanner {
	if err != nil {
		return errExample4Scanner{e: err}
	}

	return example4ScannerStatic{
		Rows: rows,
	}
}

// example4ScannerStatic generated by genieql
type example4ScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example4ScannerStatic) Scan(e *Example4) error {
	var (
		c0 pgtype.Timestamptz
		c1 pgtype.Text
		c2 pgtype.UUID
		c3 pgtype.Timestamptz
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	switch c0.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.Created = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.Created = tmp
	default:
		if err := c0.AssignTo(&e.Created); err != nil {
			return err
		}
	}

	if err := c1.AssignTo(&e.Email); err != nil {
		return err
	}

	if err := c2.AssignTo(&e.ID); err != nil {
		return err
	}

	switch c3.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.Updated = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.Updated = tmp
	default:
		if err := c3.AssignTo(&e.Updated); err != nil {
			return err
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example4ScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example4ScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example4ScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewExample4ScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewExample4ScannerStaticRow(row *sql.Row) Example4ScannerStaticRow {
	return Example4ScannerStaticRow{
		row: row,
	}
}

// Example4ScannerStaticRow generated by genieql
type Example4ScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t Example4ScannerStaticRow) Scan(e *Example4) error {
	var (
		c0 pgtype.Timestamptz
		c1 pgtype.Text
		c2 pgtype.UUID
		c3 pgtype.Timestamptz
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	switch c0.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.Created = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.Created = tmp
	default:
		if err := c0.AssignTo(&e.Created); err != nil {
			return err
		}
	}

	if err := c1.AssignTo(&e.Email); err != nil {
		return err
	}

	if err := c2.AssignTo(&e.ID); err != nil {
		return err
	}

	switch c3.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		e.Updated = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		e.Updated = tmp
	default:
		if err := c3.AssignTo(&e.Updated); err != nil {
			return err
		}
	}

	return nil
}

// Err set an error to return by scan
func (t Example4ScannerStaticRow) Err(err error) Example4ScannerStaticRow {
	t.err = err
	return t
}

// NewExample4ScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewExample4ScannerDynamic(rows *sql.Rows, err error) Example4Scanner {
	if err != nil {
		return errExample4Scanner{e: err}
	}

	return example4ScannerDynamic{
		Rows: rows,
	}
}

// example4ScannerDynamic generated by genieql
type example4ScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example4ScannerDynamic) Scan(e *Example4) error {
	const (
		cn0 = "created"
		cn1 = "email"
		cn2 = "id"
		cn3 = "updated"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pgtype.Timestamptz
		c1      pgtype.Text
		c2      pgtype.UUID
		c3      pgtype.Timestamptz
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			switch c0.InfinityModifier {
			case pgtype.Infinity:
				tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
				e.Created = tmp
			case pgtype.NegativeInfinity:
				tmp := time.Unix(math.MinInt64, math.MinInt64)
				e.Created = tmp
			default:
				if err := c0.AssignTo(&e.Created); err != nil {
					return err
				}
			}
		case cn1:
			if err := c1.AssignTo(&e.Email); err != nil {
				return err
			}
		case cn2:
			if err := c2.AssignTo(&e.ID); err != nil {
				return err
			}
		case cn3:
			switch c3.InfinityModifier {
			case pgtype.Infinity:
				tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
				e.Updated = tmp
			case pgtype.NegativeInfinity:
				tmp := time.Unix(math.MinInt64, math.MinInt64)
				e.Updated = tmp
			default:
				if err := c3.AssignTo(&e.Updated); err != nil {
					return err
				}
			}
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example4ScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example4ScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example4ScannerDynamic) Next() bool {
	return t.Rows.Next()
}
