package generators

import (
	"bufio"
	"go/ast"
	"go/types"
	"html/template"
	"io"
	"strings"

	"github.com/pkg/errors"
	"github.com/zieckey/goini"

	"bitbucket.org/jatone/genieql"
)

// StructOption option to provide the structure function.
type StructOption func(*structure)

// StructOptionName provide the name of the struct to the structure.
func StructOptionName(n string) StructOption {
	return func(s *structure) {
		s.Name = n
	}
}

// StructOptionAliasStrategy provides the default aliasing strategy for
// generating the a struct's field names.
func StructOptionAliasStrategy(mcp genieql.MappingConfigOption) StructOption {
	return func(s *structure) {
		s.aliaser = mcp
	}
}

// StructOptionRenameMap provides explicit rename mappings when
// generating the struct's field names.
func StructOptionRenameMap(m map[string]string) StructOption {
	return func(s *structure) {
		s.renameMap = genieql.MCORenameMap(m)
	}
}

// StructOptionFieldsQuery sets the query to determine the fields of the structure.
func StructOptionFieldsQuery(q string) StructOption {
	return func(s *structure) {
		s.query = genieql.MCOColumnInfo(q)
	}
}

// StructOptionConfiguration sets the genieql.Configuration for the structure generator.
func StructOptionConfiguration(c genieql.Configuration) StructOption {
	return func(s *structure) {
		s.config = c
	}
}

// StructOptionMappingConfigOptions sets the base configuration to be used for
// the MappingConfig.
func StructOptionMappingConfigOptions(options ...genieql.MappingConfigOption) StructOption {
	return func(s *structure) {
		s.mappingOptions = options
	}
}

// NewStructure creates a Generator that builds structures from column information.
func NewStructure(opts ...StructOption) genieql.Generator {
	s := structure{
		renameMap:      genieql.MCORenameMap(map[string]string{}),
		aliaser:        genieql.MCOTransformations("camelcase"),
		mappingOptions: []genieql.MappingConfigOption{},
	}

	for _, opt := range opts {
		opt(&s)
	}

	return s
}

// StructureFromGenDecl creates a structure generator from  from the provided *ast.GenDecl
func StructureFromGenDecl(decl *ast.GenDecl, options ...StructOption) []genieql.Generator {
	var (
		err        error
		configOpts []StructOption
	)

	if decl.Doc == nil {
		configOpts = options
	} else {
		if configOpts, err = configOptions(decl.Doc.Text()); err != nil {
			return []genieql.Generator{genieql.NewErrGenerator(err)}
		}
		configOpts = append(options, configOpts...)
	}

	specs := genieql.FindValueSpecs(decl)
	g := make([]genieql.Generator, 0, len(specs))

	for _, vs := range specs {
		m := mapStructureToGenerator{
			options: configOpts,
		}
		g = append(g, m.Map(vs)...)
	}

	return g
}

type structure struct {
	Name           string
	aliaser        genieql.MappingConfigOption
	renameMap      genieql.MappingConfigOption
	query          genieql.MappingConfigOption
	mappingOptions []genieql.MappingConfigOption
	config         genieql.Configuration
}

func (t structure) Generate(dst io.Writer) error {
	const tmpl = `// {{.Name}} structure generated by genieql.
type {{.Name}} struct {
	{{- range $column := .Columns }}
	{{ $column.Name | transformation }} {{ if $column.Nullable }}*{{ end }}{{ $column.Type -}}
	{{ end }}
}`
	type context struct {
		Name    string
		Columns []genieql.ColumnInfo
	}

	mapping := genieql.NewMappingConfig(append(t.mappingOptions, t.renameMap, t.aliaser, t.query, genieql.MCOType(t.Name))...)
	if err := t.config.WriteMap("default", mapping); err != nil {
		return err
	}

	columns, err := mapping.ColumnInfo()
	if err != nil {
		return err
	}

	ctx := context{
		Name:    t.Name,
		Columns: columns,
	}

	return template.Must(template.New("scanner template").Funcs(template.FuncMap{
		"transformation": mapping.Aliaser(),
	}).Parse(tmpl)).Execute(dst, ctx)
}

// ConfigOptions parses a configuration and converts it into an array of options.
func configOptions(config string) ([]StructOption, error) {
	const magicPrefix = `genieql.options:`
	const aliasOption = `alias`
	const generalSection = `general`
	const renameSection = `rename.columns`

	options := []StructOption{}

	scanner := bufio.NewScanner(strings.NewReader(config))
	scanner.Split(bufio.ScanLines)

	for scanner.Scan() {
		text := scanner.Text()
		if !strings.HasPrefix(text, magicPrefix) {
			continue
		}

		text = strings.TrimSpace(strings.TrimPrefix(text, magicPrefix))

		ini := goini.New()
		ini.SetParseSection(true)

		if err := ini.Parse([]byte(text), " ", "="); err != nil {
			return nil, errors.Wrap(err, "failed to parse comment configuration")
		}

		if kvmap, ok := ini.GetKvmap(renameSection); ok {
			options = append(options, StructOptionRenameMap(kvmap))
		}

		if kvmap, ok := ini.GetKvmap("general"); ok {
			if alias := genieql.AliaserSelect(kvmap[aliasOption]); alias != nil {
				// this could cause multiple aliasers to be applied to the Generator
				// but it doesn't matter as last one will win.
				options = append(options, StructOptionAliasStrategy(genieql.MCOTransformations(kvmap[aliasOption])))
			}
		}
	}

	return options, nil
}

type mapStructureToGenerator struct {
	options []StructOption
}

func (t mapStructureToGenerator) Map(vs *ast.ValueSpec) []genieql.Generator {
	dst := make([]genieql.Generator, 0, len(vs.Names))

	for idx := range vs.Names {
		tablename := strings.Trim(types.ExprString(vs.Values[idx]), "\"")
		s := NewStructure(
			append(t.options,
				StructOptionName(
					vs.Names[idx].Name,
				),
				StructOptionFieldsQuery(tablename),
			)...,
		)
		dst = append(dst, s)
	}

	return dst
}
