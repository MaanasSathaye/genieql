package generators

import (
	"bufio"
	"go/ast"
	"go/types"
	"html/template"
	"io"
	"strings"

	"github.com/pkg/errors"
	"github.com/zieckey/goini"

	"bitbucket.org/jatone/genieql"
)

// StructOption option to provide the structure function.
type StructOption func(*structure)

// StructOptionName provide the name of the struct to the structure.
func StructOptionName(n string) StructOption {
	return func(s *structure) {
		s.Name = n
	}
}

// StructOptionFieldsDelegate provides the fields delegate function for lookuping
// up the fields.
func StructOptionFieldsDelegate(delegate FieldsDelegate) StructOption {
	return func(s *structure) {
		s.ColumnsDelegate = delegate
	}
}

// StructOptionAliasStrategy provides the default aliasing strategy for
// generating the a struct's field names.
func StructOptionAliasStrategy(aliaser genieql.Aliaser) StructOption {
	return func(s *structure) {
		s.aliaser = aliaser
	}
}

// StructOptionRenameMap provides explicit rename mappings when
// generating the struct's field names.
func StructOptionRenameMap(m map[string]string) StructOption {
	return func(s *structure) {
		s.renameMap = m
	}
}

// FieldsDelegate extracts the fields for something within the database.
type FieldsDelegate func() ([]genieql.ColumnInfo, error)

// NewStructure creates a Generator that builds structures from column information.
func NewStructure(opts ...StructOption) genieql.Generator {
	s := structure{
		aliaser:   genieql.AliasStrategyCamelcase,
		renameMap: map[string]string{},
	}

	for _, opt := range opts {
		opt(&s)
	}

	return s
}

// StructureFromGenDecl creates a structure generator from  from the provided *ast.GenDecl
func StructureFromGenDecl(decl *ast.GenDecl, fields func(string) FieldsDelegate) []genieql.Generator {
	var (
		err     error
		options []StructOption
	)

	if decl.Doc != nil {
		if options, err = configOptions(decl.Doc.Text()); err != nil {
			return []genieql.Generator{genieql.NewErrGenerator(err)}
		}
	}

	specs := genieql.FindValueSpecs(decl)
	g := make([]genieql.Generator, 0, len(specs))

	for _, vs := range specs {
		m := mapStructureToGenerator{
			delegate: fields,
			options:  options,
		}
		g = append(g, m.Map(vs)...)
	}

	return g
}

type structure struct {
	Name            string
	ColumnsDelegate FieldsDelegate
	aliaser         genieql.Aliaser
	renameMap       map[string]string
}

func (t structure) Generate(dst io.Writer) error {
	const tmpl = `// {{.Name}} structure generated by genieql.
type {{.Name}} struct {
	{{- range $column := .Columns }}
	{{ $column.Name | transformation }} {{ if $column.Nullable }}*{{ end }}{{ $column.Type -}}
	{{ end }}
}`
	type context struct {
		Name    string
		Columns []genieql.ColumnInfo
	}

	columns, err := t.ColumnsDelegate()
	if err != nil {
		return err
	}

	alias := func(name string) string {
		// if the configuration explicitly renames
		// a column use that value do not try to
		// transform it.
		if v, ok := t.renameMap[name]; ok {
			return v
		}

		return t.aliaser.Alias(name)
	}

	ctx := context{
		Name:    t.Name,
		Columns: columns,
	}

	return template.Must(template.New("scanner template").Funcs(template.FuncMap{
		"transformation": alias,
	}).Parse(tmpl)).Execute(dst, ctx)
}

// ConfigOptions parses a configuration and converts it into an array of options.
func configOptions(config string) ([]StructOption, error) {
	const magicPrefix = `genieql.options:`
	const aliasOption = `alias`
	const generalSection = `general`
	const renameSection = `rename.columns`

	options := []StructOption{}

	scanner := bufio.NewScanner(strings.NewReader(config))
	scanner.Split(bufio.ScanLines)

	for scanner.Scan() {
		text := scanner.Text()
		if !strings.HasPrefix(text, magicPrefix) {
			continue
		}

		text = strings.TrimSpace(strings.TrimPrefix(text, magicPrefix))

		ini := goini.New()
		ini.SetParseSection(true)

		if err := ini.Parse([]byte(text), " ", "="); err != nil {
			return nil, errors.Wrap(err, "failed to parse comment configuration")
		}

		if kvmap, ok := ini.GetKvmap(renameSection); ok {
			options = append(options, StructOptionRenameMap(kvmap))
		}

		if kvmap, ok := ini.GetKvmap("general"); ok {
			if alias := genieql.AliaserSelect(kvmap[aliasOption]); alias != nil {
				// this could cause multiple aliasers to be applied to the Generator
				// but it doesn't matter as last one will win.
				options = append(options, StructOptionAliasStrategy(alias))
			}
		}
	}

	return options, nil
}

type mapStructureToGenerator struct {
	options  []StructOption
	delegate func(string) FieldsDelegate
}

func (t mapStructureToGenerator) Map(vs *ast.ValueSpec) []genieql.Generator {
	dst := make([]genieql.Generator, 0, len(vs.Names))

	for idx := range vs.Names {
		tablename := types.ExprString(vs.Values[idx])
		s := NewStructure(
			append(t.options,
				StructOptionName(
					vs.Names[idx].Name,
				),
				StructOptionFieldsDelegate(t.delegate(tablename)),
			)...,
		)
		dst = append(dst, s)
	}

	return dst
}
