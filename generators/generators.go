package generators

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/token"
	"io"
	"log"

	"bitbucket.org/jatone/genieql"
)

// Generators generate schema and configuration for testing.
//go:generate dropdb --if-exists -U postgres genieql_test_template
//go:generate createdb -U postgres genieql_test_template
//go:generate psql -X -1 -f structure.sql genieql_test_template
//go:generate genieql bootstrap --queryer=sqlx.Queryer --driver=github.com/jackc/pgx --output-file=generators-test.config postgres://$USER@localhost:5432/genieql_test_template?sslmode=disable

// Logging levels
const (
	VerbosityError = iota
	VerbosityWarn
	VerbosityInfo
	VerbosityDebug
	VerbosityTrace
)

// Context - context for generators
type Context struct {
	Build          build.Context
	CurrentPackage *build.Package
	FileSet        *token.FileSet
	Configuration  genieql.Configuration
	Dialect        genieql.Dialect
	Driver         genieql.Driver
	Verbosity      int
}

// Println ...
func (t Context) Println(args ...interface{}) {
	if t.Verbosity < VerbosityInfo {
		return
	}

	log.Output(2, fmt.Sprintln(args...))
}

// Printf ...
func (t Context) Printf(format string, args ...interface{}) {
	if t.Verbosity < VerbosityInfo {
		return
	}

	log.Output(2, fmt.Sprintf(format, args...))
}

// Debug logs
func (t Context) Debug(args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	log.Output(2, fmt.Sprint(args...))
}

// Debugf logs
func (t Context) Debugf(format string, args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	log.Output(2, fmt.Sprintf(format, args...))
}

// Debugln logs
func (t Context) Debugln(args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	log.Output(2, fmt.Sprintln(args...))
}

// Traceln detailed logging
func (t Context) Traceln(args ...interface{}) {
	if t.Verbosity < VerbosityTrace {
		return
	}

	log.Output(2, fmt.Sprintln(args...))
}

func reserved(s string) bool {
	switch s {
	case "type":
		return true
	case "func":
		return true
	case "default":
		return true
	default:
		return false
	}
}

// GenerateComment generates a comment.
func GenerateComment(comments ...*ast.CommentGroup) genieql.Generator {
	doc := firstComment(comments...)
	return genieql.NewFuncGenerator(func(dst io.Writer) (err error) {
		for _, c := range doc.List {
			if _, err = dst.Write([]byte(c.Text)); err != nil {
				return err
			}

			if _, err = dst.Write([]byte("\n")); err != nil {
				return err
			}
		}

		return nil
	})
}

func DefaultFunctionComment(name string) *ast.CommentGroup {
	return &ast.CommentGroup{
		List: []*ast.Comment{
			{Text: fmt.Sprintf("// %s generated by genieql", name)},
		},
	}
}

func firstComment(comments ...*ast.CommentGroup) *ast.CommentGroup {
	for _, c := range comments {
		if c != nil {
			return c
		}
	}

	return nil
}
