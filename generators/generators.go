package generators

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"

	"bitbucket.org/jatone/genieql"
	"bitbucket.org/jatone/genieql/dialects"
)

// Generators generate schema and configuration for testing.
//go:generate dropdb --if-exists -U postgres genieql_test_template
//go:generate createdb -U postgres genieql_test_template
//go:generate psql -X -1 -f structure.sql genieql_test_template
//go:generate genieql bootstrap --queryer=sqlx.Queryer --driver=github.com/jackc/pgx --output-file=generators-test.config postgres://$USER@localhost:5432/genieql_test_template?sslmode=disable

// Logging levels
const (
	VerbosityError = iota
	VerbosityWarn
	VerbosityInfo
	VerbosityDebug
	VerbosityTrace
)

// Context - context for generators
type Context struct {
	Build          build.Context
	CurrentPackage *build.Package
	FileSet        *token.FileSet
	Configuration  genieql.Configuration
	Dialect        genieql.Dialect
	Driver         genieql.Driver
	Verbosity      int
	OSArgs         []string
}

// Println ...
func (t Context) Println(args ...interface{}) {
	if t.Verbosity < VerbosityInfo {
		return
	}

	log.Output(2, fmt.Sprintln(args...))
}

// Printf ...
func (t Context) Printf(format string, args ...interface{}) {
	if t.Verbosity < VerbosityInfo {
		return
	}

	log.Output(2, fmt.Sprintf(format, args...))
}

// Debug logs
func (t Context) Debug(args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	log.Output(2, fmt.Sprint(args...))
}

// Debugf logs
func (t Context) Debugf(format string, args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	log.Output(2, fmt.Sprintf(format, args...))
}

// Debugln logs
func (t Context) Debugln(args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	log.Output(2, fmt.Sprintln(args...))
}

// Traceln detailed logging
func (t Context) Traceln(args ...interface{}) {
	if t.Verbosity < VerbosityTrace {
		return
	}

	log.Output(2, fmt.Sprintln(args...))
}

func reserved(s string) bool {
	switch s {
	case "type":
		return true
	case "func":
		return true
	case "default":
		return true
	default:
		return false
	}
}

// GenerateComment generates a comment.
func GenerateComment(comments ...*ast.CommentGroup) genieql.Generator {
	doc := mergeComments(comments...)
	return genieql.NewFuncGenerator(func(dst io.Writer) (err error) {
		for _, c := range doc.List {
			if _, err = dst.Write([]byte(c.Text)); err != nil {
				return err
			}

			if _, err = dst.Write([]byte("\n")); err != nil {
				return err
			}
		}

		return nil
	})
}

func GapLines(dst io.Writer, n int) (err error) {
	for i := 0; i < n; i++ {
		if _, err = fmt.Fprintln(dst); err != nil {
			return err
		}
	}

	return nil
}

func DefaultFunctionComment(name string) *ast.CommentGroup {
	return &ast.CommentGroup{
		List: []*ast.Comment{
			{Text: fmt.Sprintf("// %s generated by genieql", name)},
		},
	}
}

func mergeComments(comments ...*ast.CommentGroup) (m *ast.CommentGroup) {
	for _, c := range comments {
		if c == nil {
			continue
		}

		if m == nil {
			m = c
			continue
		}
		m.List = append(m.List, c.List...)
	}

	return m
}

type Option func(*Context)

func OptionOSArgs(args ...string) Option {
	return func(ctx *Context) {
		ctx.OSArgs = args
	}
}

func NewContext(bctx build.Context, name, pkg string, options ...Option) (ctx Context, err error) {
	var (
		config  genieql.Configuration
		dialect genieql.Dialect
		driver  genieql.Driver
		bpkg    *build.Package
	)

	config = genieql.MustReadConfiguration(
		genieql.ConfigurationOptionLocation(
			filepath.Join(genieql.ConfigurationDirectory(), name),
		),
	)

	if dialect, err = dialects.LookupDialect(config); err != nil {
		return ctx, err
	}

	if driver, err = genieql.LookupDriver(config.Driver); err != nil {
		return ctx, err
	}

	if bpkg, err = genieql.LocatePackage(pkg, bctx, genieql.StrictPackageImport(pkg)); err != nil {
		return ctx, err
	}

	ctx = Context{
		Build:          bctx,
		CurrentPackage: bpkg,
		FileSet:        token.NewFileSet(),
		Configuration:  config,
		Dialect:        dialect,
		Driver:         driver,
		OSArgs:         os.Args[1:],
	}

	for _, opt := range options {
		opt(&ctx)
	}

	return ctx, nil
}
